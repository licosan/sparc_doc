{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to SPARC ___ ____ __ ____ ___ / __)( _ \\ /__\\ ( _ \\ / __) ___\\__ \\ )___//(__)\\ ) /( (__ (_______/(__) (__)(__)(_)\\_) \\___) Single Page Applications Rational Code Sparc is a javascript MVC framework for Single Page Applications Sparc main objectives MVC Sparc is a framework with the MVC architectural pattern at its center. MVC has been used exptensively for traditional web application, on the server side, for decades in every possible programming language: for example, think about Ruby-on-Rails in Ruby, Django in Python, CodeIgniter / Zend in PHP, Spring / JSF / Struts in Java just to name a few. With the advent of Single Page Applications, the front-end (browser) side of applications now also needs an architectural pattern that can structure large amounts of code, and MVC fits just as well. Models, Views, Controllers and Routing on the client-side (browser) have the same purpose as they have on the server-side. Sparc implements a corresponding file structure for your scripts (models, View & Controllers), plus templates and configuration files. Be aware: You should be familliar with the MVC pattern before digging any further into this doc. You'll find plenty of cool introductions one the web if you think you need it. Truly detached Your application boots, and serves all its different URLs without the help of a backend server. Only static files are used. The backend server is only there to answer to AJAX requests. Small footprint, fast serving Loads only what you need, just when you need it: Scripts and Assets (images, fonts, css, ...) are loaded only once (clever non-browser caching), only when needed (lazy-loading). Load few and small components from the server, Have a small footprint in the bowser memory, Minimal code exposure: Expose to he user only the javascript code that this user needs and no more. Clever Loading Scripts can depend on other scripts and on Assets. Define your dependency trees in clear JSON files, and Sparc will make sure everything your script needs is loaded beforehand. The loading is also optimized by loading several things in parallel, but only where there is no risk to break a dependency. Powerful URL Routing Sparc lets you define route patterns in readable JSON files. Routes can be nested: a controller can redefine its own scope of routes. The URL patterns can use Regular Expressions, to extract named parameters. Methods can be specified, or not. A best match strategy is used when several routes are matching the URL + User role combination. Forward / Back buttons and internal links are intercepted to avoid any unwanted reload and the user is warned before exiting the application. External error logging Javascript Warnings and Errors in the console (from your code or directly from the browser) can trigger a fire-and-forget Ajax to any external service to have them store in a database, sent formated emails, etc... The error-level, the stack-trace and all relevant informations (like url, user, user-role) are included in the Json.","title":"What is it & why?"},{"location":"index.html#welcome-to-sparc","text":"___ ____ __ ____ ___ / __)( _ \\ /__\\ ( _ \\ / __) ___\\__ \\ )___//(__)\\ ) /( (__ (_______/(__) (__)(__)(_)\\_) \\___) Single Page Applications Rational Code","title":"Welcome to SPARC"},{"location":"index.html#sparc-is-a-javascript-mvc-framework-for-single-page-applications","text":"","title":"Sparc is a javascript MVC framework for Single Page Applications"},{"location":"index.html#sparc-main-objectives","text":"MVC Sparc is a framework with the MVC architectural pattern at its center. MVC has been used exptensively for traditional web application, on the server side, for decades in every possible programming language: for example, think about Ruby-on-Rails in Ruby, Django in Python, CodeIgniter / Zend in PHP, Spring / JSF / Struts in Java just to name a few. With the advent of Single Page Applications, the front-end (browser) side of applications now also needs an architectural pattern that can structure large amounts of code, and MVC fits just as well. Models, Views, Controllers and Routing on the client-side (browser) have the same purpose as they have on the server-side. Sparc implements a corresponding file structure for your scripts (models, View & Controllers), plus templates and configuration files. Be aware: You should be familliar with the MVC pattern before digging any further into this doc. You'll find plenty of cool introductions one the web if you think you need it. Truly detached Your application boots, and serves all its different URLs without the help of a backend server. Only static files are used. The backend server is only there to answer to AJAX requests. Small footprint, fast serving Loads only what you need, just when you need it: Scripts and Assets (images, fonts, css, ...) are loaded only once (clever non-browser caching), only when needed (lazy-loading). Load few and small components from the server, Have a small footprint in the bowser memory, Minimal code exposure: Expose to he user only the javascript code that this user needs and no more. Clever Loading Scripts can depend on other scripts and on Assets. Define your dependency trees in clear JSON files, and Sparc will make sure everything your script needs is loaded beforehand. The loading is also optimized by loading several things in parallel, but only where there is no risk to break a dependency. Powerful URL Routing Sparc lets you define route patterns in readable JSON files. Routes can be nested: a controller can redefine its own scope of routes. The URL patterns can use Regular Expressions, to extract named parameters. Methods can be specified, or not. A best match strategy is used when several routes are matching the URL + User role combination. Forward / Back buttons and internal links are intercepted to avoid any unwanted reload and the user is warned before exiting the application. External error logging Javascript Warnings and Errors in the console (from your code or directly from the browser) can trigger a fire-and-forget Ajax to any external service to have them store in a database, sent formated emails, etc... The error-level, the stack-trace and all relevant informations (like url, user, user-role) are included in the Json.","title":"Sparc main objectives"},{"location":"app_config.html","text":"2. Application configuration There are two Json files located in /app/config : appConfig.json : General configuration parameters for this application. baseRoutes.json : Defines the top-level routes General configuration This configuration Json file contains one separated block for every configurable core library. Logger config (key: \"logger\") enabled : Boolean When false, the logger is ...disabled ;-) Importantly, that means that the browser console remains the original one. levels : Array Containing either 'warn', 'error' or both. postUrl : String The Url where the Json of the error will be posted Example config block: \"logger\": { \"enabled\": true, \"levels\": [\"warn\", \"err\"], \"postUrl\": \"https://mydomain.com/log2mail.php\" }, Example Error posted: \"level\": \"WARNING\", \"message\": \"In template employeeViews/EmployeeView.html, badvariable is not defined !\", \"user\": \"nike\", \"url\": \"https://mydomain.com/employees\", \"appName\": \"MyApp 2.0\", \"stacktrace\": [ [\"processTemplate\",\"Assets.js\",[\"221\",\"25\"]], [\"replaceByHtml\",\"Assets.js\",[\"241\",\"66\"]], [\"loadHtml\",\"Assets.js\",[\"182\",\"56\"]], [\"replaceByHtml\",\"Assets.js\",[\"246\",\"14\"]], [\"...all the way up to Sparc-core...\"] ] Assets manager config basePath : String The path where all assets are stored Example config block: \"assets\": { \"basePath\": \"/app/assets/\" }, Router config getRoleFrom : String This is a String that represents a function or method . It Will be called by the router to get the role used in routing. Standard value is \"app.User.getRole\" , which uses the (early loaded) User class that you can override (see \"Custom User class\" below) Caution : This is needed early in the routing process, and therefore should be able to answer right away (no promise). If this string does not represent a callable, it is used as a plain string value. (useful for no-login-dev-mode) controllersPath : String The root path of controllers. Standard value is \"/app/controllers\" *. modelsPath : String The root path of models. Standard value is \"/app/models\" *. viewsPath : String The root path of views. Standard value is \"/app/views\" *. Example config block: \"router\": { \"getRoleFrom\": \"app.User.getRole\", \"controllersPath\": \"/app/controllers/\", \"modelsPath\": \"/app/models/\", \"viewsPath\": \"/app/views/\" }, Custom User class String This is the name (without .js) of the file containing your override of the User class. Caution : The file cannot be called \"User\", as the loader would consider this class is already loaded. (the Baseclass is indeed) Look at the base class at /core/baseClasses/User.js to see the interface. Here is a typical example : 'use strict' app.LoadedClasses.User = class extends app.LoadedClasses.User { constructor(){ super(); } checkAuthenticated(callBack){ // Call an service to know if we are logged in fetch('https://mydomain/checkAuthenticated?'+crypto.randomUUID(),{ method: 'GET', credentials: 'include' }) .then(response => response.json()) .then(resp => { if(resp.success){ this.isAuthenticated = resp.data.isAuthenticated; if(resp.data.isAuthenticated) { // Meanwhile get user infos this.userInfo = resp.data.userInfo; callBack(); } else { console.warn('User was not authenticated !'); this.authUrl = resp.data.authUrl; callBack(); // sparCore defaults is call gotoLogin below } } else { console.error('Server error calling checkAuthenticated !?') } }); } gotoLogin(){ // Redirect, or call a service, or show a login button... document.location.href = 'https://mydomain.com/login.php'; } } Plugins config For each of the available plugins, there is usually a a configuration block of the same name. Normally, plugins should have a enabled flag to enable them. Top level routes definition Here are the definitions of the top-level routes used by the router. This file contains a Json Array of route objects such as for example : { \"url\": \"/module1/user:uid(\\\\d+)\", \"role\": \"theboss\", \"controller\" : \"/common/User/UserCtrl\", \"method\": \"userMod\" }, If you have tons of routes and want to keep this file reasonable, you can delegate \"sub-routes\" at each controller level. See \"Understanding the routing\" section for more details.","title":"2. Configure your app"},{"location":"app_config.html#2-application-configuration","text":"There are two Json files located in /app/config : appConfig.json : General configuration parameters for this application. baseRoutes.json : Defines the top-level routes","title":"2. Application configuration"},{"location":"app_config.html#general-configuration","text":"This configuration Json file contains one separated block for every configurable core library.","title":"General configuration"},{"location":"app_config.html#logger-config-key-logger","text":"enabled : Boolean When false, the logger is ...disabled ;-) Importantly, that means that the browser console remains the original one. levels : Array Containing either 'warn', 'error' or both. postUrl : String The Url where the Json of the error will be posted Example config block: \"logger\": { \"enabled\": true, \"levels\": [\"warn\", \"err\"], \"postUrl\": \"https://mydomain.com/log2mail.php\" }, Example Error posted: \"level\": \"WARNING\", \"message\": \"In template employeeViews/EmployeeView.html, badvariable is not defined !\", \"user\": \"nike\", \"url\": \"https://mydomain.com/employees\", \"appName\": \"MyApp 2.0\", \"stacktrace\": [ [\"processTemplate\",\"Assets.js\",[\"221\",\"25\"]], [\"replaceByHtml\",\"Assets.js\",[\"241\",\"66\"]], [\"loadHtml\",\"Assets.js\",[\"182\",\"56\"]], [\"replaceByHtml\",\"Assets.js\",[\"246\",\"14\"]], [\"...all the way up to Sparc-core...\"] ]","title":"Logger config (key: \"logger\")"},{"location":"app_config.html#assets-manager-config","text":"basePath : String The path where all assets are stored Example config block: \"assets\": { \"basePath\": \"/app/assets/\" },","title":"Assets manager config"},{"location":"app_config.html#router-config","text":"getRoleFrom : String This is a String that represents a function or method . It Will be called by the router to get the role used in routing. Standard value is \"app.User.getRole\" , which uses the (early loaded) User class that you can override (see \"Custom User class\" below) Caution : This is needed early in the routing process, and therefore should be able to answer right away (no promise). If this string does not represent a callable, it is used as a plain string value. (useful for no-login-dev-mode) controllersPath : String The root path of controllers. Standard value is \"/app/controllers\" *. modelsPath : String The root path of models. Standard value is \"/app/models\" *. viewsPath : String The root path of views. Standard value is \"/app/views\" *. Example config block: \"router\": { \"getRoleFrom\": \"app.User.getRole\", \"controllersPath\": \"/app/controllers/\", \"modelsPath\": \"/app/models/\", \"viewsPath\": \"/app/views/\" },","title":"Router config"},{"location":"app_config.html#custom-user-class","text":"String This is the name (without .js) of the file containing your override of the User class. Caution : The file cannot be called \"User\", as the loader would consider this class is already loaded. (the Baseclass is indeed) Look at the base class at /core/baseClasses/User.js to see the interface. Here is a typical example : 'use strict' app.LoadedClasses.User = class extends app.LoadedClasses.User { constructor(){ super(); } checkAuthenticated(callBack){ // Call an service to know if we are logged in fetch('https://mydomain/checkAuthenticated?'+crypto.randomUUID(),{ method: 'GET', credentials: 'include' }) .then(response => response.json()) .then(resp => { if(resp.success){ this.isAuthenticated = resp.data.isAuthenticated; if(resp.data.isAuthenticated) { // Meanwhile get user infos this.userInfo = resp.data.userInfo; callBack(); } else { console.warn('User was not authenticated !'); this.authUrl = resp.data.authUrl; callBack(); // sparCore defaults is call gotoLogin below } } else { console.error('Server error calling checkAuthenticated !?') } }); } gotoLogin(){ // Redirect, or call a service, or show a login button... document.location.href = 'https://mydomain.com/login.php'; } }","title":"Custom User class"},{"location":"app_config.html#plugins-config","text":"For each of the available plugins, there is usually a a configuration block of the same name. Normally, plugins should have a enabled flag to enable them.","title":"Plugins config"},{"location":"app_config.html#top-level-routes-definition","text":"Here are the definitions of the top-level routes used by the router. This file contains a Json Array of route objects such as for example : { \"url\": \"/module1/user:uid(\\\\d+)\", \"role\": \"theboss\", \"controller\" : \"/common/User/UserCtrl\", \"method\": \"userMod\" }, If you have tons of routes and want to keep this file reasonable, you can delegate \"sub-routes\" at each controller level. See \"Understanding the routing\" section for more details.","title":"Top level routes definition"},{"location":"assets_mgr.html","text":"5. Assets manager The assets manager has three purposes: It take care of the loading or pre-loading of your assest like images, styles, fonts, sounds, html fragments (or templates), or json fragments. It takes care of caching: the same asset is never loaded twice as long as you stay in the app, but as soon as the app is reloaded, everything is reloaded (no more browser-cache surprises). It provides helper methods adapted to each asset type, to help you use them. Auto-preloading: In many situations, the assets manager will in fact be used automatically by the dependency system, to preload what you need son you don't need to worry about it. However, Asstes manager also comes with a number of helper methods that simplify the way you'll use the asset once it is pre-loaded. They are detailed below together with their respective preloading method. General remarks for all assets manager's methods: All Assets manager methods share these parameters : name : String [Mandatory] the name of the asset to be loaded. If the file extention is absent, the typical one will be added. It should not contain the path to the file. path : String [Optional] The path to the file, if you are using subfolders below the respective assets folders. If absent, the file is loaded directly at from the /app/assets/[asset-type]/[name] refresh : Boolean [Optional] If present and true, forces the asset to be reloaded, even if it was already preloaded. callback : Function [Optional] If present and callable, it will be called as soon as the asset is loaded and available. (Thus immediately if the assets was already preloaded). The callabck argument is always the instance of the loaded asset. It will also be called when the assets loading fails, just after the server's response. In this case the callback argument is null (so you know something went bad). Upon such a failure, a warning is also issued at the console. Pre-loading is not mandatory: All the methods of assets manager that help you \"* use\"\" asset (as opposed to those just loading it), will be happy if you invoke them on a non-already-loaded asset. In this case, the method in question will just load the asset last-minute for you. But then why should you bother declaring them as dependencies ? Well, depending on your server, on the internet connection of the user, and on the weight of the asset, and what you are doing with it, the loading time might be preceptible for the user or not. For example, an image showing up 500ms late is usually not a big issue, but a sound triggered by a user interaction that starts playing even 300ms late will be clearly perceptible. Available methods for the different asset types: Images assets GetImage : Preloads an image, and returns a TMG Dom node, not attached to the document. If the image was already preloaded, the node will be cloned, and the clone returned. appendImage : The argument selector String [Mandatory] , is used as a traditional Dom selector, and the image is appended at the end of that node . If the image was not preloaded (manually or via a dependency), it is loaded last minute. prependImage : The argument selector String [Mandatory] , is used as a traditional Dom selector, and the image is appended at the beginning of that node . If the image was not preloaded (manually or via a dependency), it is loaded last minute. Fonts assets loadFont : Preloads a font, then creates a fontFace object. The fontFace is then added to the Dom, and the corresponding node is used in the callback, together with the Font's acronym (=font-familly name). If the name argument did not include an extension, the extension '.ttf' will be used by default (possible extension are '.ttf', '.otf' and 'woff' ). There are no helper function for fonts. (using them just means using their acronym (=font-familly name) in some styling) Styles assets LoadCss : Loads a CSS file and applies it. There are no helper function for css. (css references can be used as soon as the css is loaded) Sounds assets loadSound : Preloads a sound. if no file extension is given, '.mp3' is assumed. The sound is not played. As soon as it is fully-loaded (readyState = 'canplaythrough'), the callback returns the Audio element playSound : Plays a preloaded sound, from beginning to end. One particular sound must finish playing before you play it again (no overlap with itself), but sound can be played while another sound is still playing (overlap between different sounds). Sound assets used here are just intended to embellish and improve a UI experience. They are supposed to be short and meaningfull. The assets manager is not made to play long mp3 (like music or so), where you'd want to provide some kind controls like pause, rewind, volume etc. Json assets LoadJson : Preloads a json file, and returns the corresponding (parsed) objectvia the callback. This is made for \"Static\" Json files (like some config, user defaults,...) that are not meant to change during the app. usage. Any (even slightly-) dynamic data shall probably come from your back-end server, via one of your controllers. Html assets loadHtml : Loads an html fragment, or a template. replaceByHtml : Uses an HTML fragment or template as replacement for the inner content of Dom each nodes given by the css selector (given by the selector argument). If the argument templateData is a key-value object, the asset is considered as a template that is processed as a template literals . For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) replaceByView : Same as replaceByHtml , but assuming the path starts in /app/views . appendHtml : Creates a Dom element of type element argument (defaults to 'div'). Fills its inner content with the HTML fragment or template. Then adds this element at the end of each Dom nodes given by the css selector (given by the selector argument). If the argument templateData is a key-value object, the asset is considered as a template that is processed as a template literals . For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) appendView : Same as appendHtml , but assuming the path starts in /app/views . prependHtml : Creates a Dom element of type element argument (defaults to 'div'). Fills its inner content with the HTML fragment or template. Then adds this element at the beginning of each Dom nodes given by the css selector (given by the selector argument). If the argument templateData is a key-value object, the asset is considered as a template that is processed as a template literals . For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) prependView : Same as prependHtml , but assuming the path starts in /app/views . processTemplate : Used internally by the methods above tp process the html when it is considered as a template. For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) In case you'd want to use it directly, you'd call it with the followinf arguments: name String Template name, just used for console warnings when the pre-flight check fails. html String Template content templateData Key-value Object used for the evaluation of expressions. It returns a String containing the processed template.","title":"5. Use Assets Manager"},{"location":"assets_mgr.html#5-assets-manager","text":"The assets manager has three purposes: It take care of the loading or pre-loading of your assest like images, styles, fonts, sounds, html fragments (or templates), or json fragments. It takes care of caching: the same asset is never loaded twice as long as you stay in the app, but as soon as the app is reloaded, everything is reloaded (no more browser-cache surprises). It provides helper methods adapted to each asset type, to help you use them. Auto-preloading: In many situations, the assets manager will in fact be used automatically by the dependency system, to preload what you need son you don't need to worry about it. However, Asstes manager also comes with a number of helper methods that simplify the way you'll use the asset once it is pre-loaded. They are detailed below together with their respective preloading method.","title":"5. Assets manager"},{"location":"assets_mgr.html#general-remarks-for-all-assets-managers-methods","text":"All Assets manager methods share these parameters : name : String [Mandatory] the name of the asset to be loaded. If the file extention is absent, the typical one will be added. It should not contain the path to the file. path : String [Optional] The path to the file, if you are using subfolders below the respective assets folders. If absent, the file is loaded directly at from the /app/assets/[asset-type]/[name] refresh : Boolean [Optional] If present and true, forces the asset to be reloaded, even if it was already preloaded. callback : Function [Optional] If present and callable, it will be called as soon as the asset is loaded and available. (Thus immediately if the assets was already preloaded). The callabck argument is always the instance of the loaded asset. It will also be called when the assets loading fails, just after the server's response. In this case the callback argument is null (so you know something went bad). Upon such a failure, a warning is also issued at the console. Pre-loading is not mandatory: All the methods of assets manager that help you \"* use\"\" asset (as opposed to those just loading it), will be happy if you invoke them on a non-already-loaded asset. In this case, the method in question will just load the asset last-minute for you. But then why should you bother declaring them as dependencies ? Well, depending on your server, on the internet connection of the user, and on the weight of the asset, and what you are doing with it, the loading time might be preceptible for the user or not. For example, an image showing up 500ms late is usually not a big issue, but a sound triggered by a user interaction that starts playing even 300ms late will be clearly perceptible.","title":"General remarks for all assets manager's methods:"},{"location":"assets_mgr.html#available-methods-for-the-different-asset-types","text":"","title":"Available methods for the different asset types:"},{"location":"assets_mgr.html#images-assets","text":"GetImage : Preloads an image, and returns a TMG Dom node, not attached to the document. If the image was already preloaded, the node will be cloned, and the clone returned. appendImage : The argument selector String [Mandatory] , is used as a traditional Dom selector, and the image is appended at the end of that node . If the image was not preloaded (manually or via a dependency), it is loaded last minute. prependImage : The argument selector String [Mandatory] , is used as a traditional Dom selector, and the image is appended at the beginning of that node . If the image was not preloaded (manually or via a dependency), it is loaded last minute.","title":"Images assets"},{"location":"assets_mgr.html#fonts-assets","text":"loadFont : Preloads a font, then creates a fontFace object. The fontFace is then added to the Dom, and the corresponding node is used in the callback, together with the Font's acronym (=font-familly name). If the name argument did not include an extension, the extension '.ttf' will be used by default (possible extension are '.ttf', '.otf' and 'woff' ). There are no helper function for fonts. (using them just means using their acronym (=font-familly name) in some styling)","title":"Fonts assets"},{"location":"assets_mgr.html#styles-assets","text":"LoadCss : Loads a CSS file and applies it. There are no helper function for css. (css references can be used as soon as the css is loaded)","title":"Styles assets"},{"location":"assets_mgr.html#sounds-assets","text":"loadSound : Preloads a sound. if no file extension is given, '.mp3' is assumed. The sound is not played. As soon as it is fully-loaded (readyState = 'canplaythrough'), the callback returns the Audio element playSound : Plays a preloaded sound, from beginning to end. One particular sound must finish playing before you play it again (no overlap with itself), but sound can be played while another sound is still playing (overlap between different sounds). Sound assets used here are just intended to embellish and improve a UI experience. They are supposed to be short and meaningfull. The assets manager is not made to play long mp3 (like music or so), where you'd want to provide some kind controls like pause, rewind, volume etc.","title":"Sounds assets"},{"location":"assets_mgr.html#json-assets","text":"LoadJson : Preloads a json file, and returns the corresponding (parsed) objectvia the callback. This is made for \"Static\" Json files (like some config, user defaults,...) that are not meant to change during the app. usage. Any (even slightly-) dynamic data shall probably come from your back-end server, via one of your controllers.","title":"Json assets"},{"location":"assets_mgr.html#html-assets","text":"loadHtml : Loads an html fragment, or a template. replaceByHtml : Uses an HTML fragment or template as replacement for the inner content of Dom each nodes given by the css selector (given by the selector argument). If the argument templateData is a key-value object, the asset is considered as a template that is processed as a template literals . For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) replaceByView : Same as replaceByHtml , but assuming the path starts in /app/views . appendHtml : Creates a Dom element of type element argument (defaults to 'div'). Fills its inner content with the HTML fragment or template. Then adds this element at the end of each Dom nodes given by the css selector (given by the selector argument). If the argument templateData is a key-value object, the asset is considered as a template that is processed as a template literals . For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) appendView : Same as appendHtml , but assuming the path starts in /app/views . prependHtml : Creates a Dom element of type element argument (defaults to 'div'). Fills its inner content with the HTML fragment or template. Then adds this element at the beginning of each Dom nodes given by the css selector (given by the selector argument). If the argument templateData is a key-value object, the asset is considered as a template that is processed as a template literals . For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) prependView : Same as prependHtml , but assuming the path starts in /app/views . processTemplate : Used internally by the methods above tp process the html when it is considered as a template. For more info about templating in Sparc, check the Views section of \"Write your MVC components\" ) In case you'd want to use it directly, you'd call it with the followinf arguments: name String Template name, just used for console warnings when the pre-flight check fails. html String Template content templateData Key-value Object used for the evaluation of expressions. It returns a String containing the processed template.","title":"Html assets"},{"location":"dependencies.html","text":"Dependencies definition Models and Views (sript) dependencies Other (script) dependencies Assets depedencies Special case of view-associated templates","title":"Dependencies definition"},{"location":"dependencies.html#dependencies-definition","text":"","title":"Dependencies definition"},{"location":"dependencies.html#models-and-views-sript-dependencies","text":"","title":"Models and Views (sript) dependencies"},{"location":"dependencies.html#other-script-dependencies","text":"","title":"Other (script) dependencies"},{"location":"dependencies.html#assets-depedencies","text":"","title":"Assets depedencies"},{"location":"dependencies.html#special-case-of-view-associated-templates","text":"","title":"Special case of view-associated templates"},{"location":"file_structure.html","text":"1. Sparc file structure Root directory : /app This is where your application lives, where you'll do your dev. work. /core This is where Sparc mechanics lives (you should not need to touch anything in here). /index.html This is the only HTML page ever loaded by your browser. These 10 lines of HTML are bootstrapping Sparc. (see the section about configuring your Nginx / Apache for Sparc) /core : You should not have to change anyting in here. If you do find something helpfull to change in the Core, please consider making a pull-request ;-) * /baseClasses - Contains model, view, controller and user base classes * /helpers - Helpers for Sparc itself * /libs - Libraries for sparc itself. Here lives the Router, the Assets manager, the Logger and the MessageBus. * /Sparc-core-1.0.js - Sparc bootstrap script. This is also where the Loader lives, as it is immediately needed to load internal (core) libs and MVC base-classes. * /utils /app : /assets This folder contains your images, fonts, style-sheets, sounds, static json, and html templates. This default path could be changed via assets.basePath setting in the application config. /config This folder contains json configuration files. /controllers This folder contains your controllers, eventually in a directory structure. This default path can be changed via router.controllersPath setting in the app. config. /docs This is where you should document your application...just a siggestion ;-). /helpers Put here any short, reusable piece of script that can be usefull anywhere in your app (any MVC components). Typically, you'll want to define global functions here like a date-conversion function, or enrich javascript-core prototypes, like adding a 'toCurrency' formatting method to the Number type for example. /libs Put here your large scripts, implementing a specific set of features that are not suited in a model, view or controller. Typically, a library defines a class that will be instantiated by models, views of controllers. thirdparty Put here any external libraries that you need. You probably want to git-ignore this folder ! /models This folder contains your models, eventually in a directory structure. This default path can be changed via router.modelsPath setting in the app. config. /views This folder contains your views, eventually in a directory structure. This default path can be changed via router.viewsPath setting in the app. config. /app/assets : fonts Put here all the fonts (like .ttf, .otf, .woff) that some of your views depends upon. html Put here all the static html fragments you might need in your views. Templating is allowed, using the standard \"template literals\" syntax of javascript. Template interpretation will activate if anf only if you pass a templateData object to the asset helpers functions. This is for general-purpose HTML fragments / templates. When your template is uniquely tied to a specific view, you probably want to store it in the views folder, alongside the corresponding javascript file (same name but .html). See the topic \"Using Assets manager\") images Put here all the images that some of your views depends upon. json Put here any piece of STATIC json that any component might depends upon. sfx Put here all the .mp3 sounds that some of your views depends upon. styles Put here all the .css files that some of your views depends upon.","title":"1. Understand the file structure"},{"location":"file_structure.html#1-sparc-file-structure","text":"","title":"1. Sparc file structure"},{"location":"file_structure.html#root-directory","text":"/app This is where your application lives, where you'll do your dev. work. /core This is where Sparc mechanics lives (you should not need to touch anything in here). /index.html This is the only HTML page ever loaded by your browser. These 10 lines of HTML are bootstrapping Sparc. (see the section about configuring your Nginx / Apache for Sparc)","title":"Root directory :"},{"location":"file_structure.html#core","text":"You should not have to change anyting in here. If you do find something helpfull to change in the Core, please consider making a pull-request ;-) * /baseClasses - Contains model, view, controller and user base classes * /helpers - Helpers for Sparc itself * /libs - Libraries for sparc itself. Here lives the Router, the Assets manager, the Logger and the MessageBus. * /Sparc-core-1.0.js - Sparc bootstrap script. This is also where the Loader lives, as it is immediately needed to load internal (core) libs and MVC base-classes. * /utils","title":"/core :"},{"location":"file_structure.html#app","text":"/assets This folder contains your images, fonts, style-sheets, sounds, static json, and html templates. This default path could be changed via assets.basePath setting in the application config. /config This folder contains json configuration files. /controllers This folder contains your controllers, eventually in a directory structure. This default path can be changed via router.controllersPath setting in the app. config. /docs This is where you should document your application...just a siggestion ;-). /helpers Put here any short, reusable piece of script that can be usefull anywhere in your app (any MVC components). Typically, you'll want to define global functions here like a date-conversion function, or enrich javascript-core prototypes, like adding a 'toCurrency' formatting method to the Number type for example. /libs Put here your large scripts, implementing a specific set of features that are not suited in a model, view or controller. Typically, a library defines a class that will be instantiated by models, views of controllers. thirdparty Put here any external libraries that you need. You probably want to git-ignore this folder ! /models This folder contains your models, eventually in a directory structure. This default path can be changed via router.modelsPath setting in the app. config. /views This folder contains your views, eventually in a directory structure. This default path can be changed via router.viewsPath setting in the app. config.","title":"/app :"},{"location":"file_structure.html#appassets","text":"fonts Put here all the fonts (like .ttf, .otf, .woff) that some of your views depends upon. html Put here all the static html fragments you might need in your views. Templating is allowed, using the standard \"template literals\" syntax of javascript. Template interpretation will activate if anf only if you pass a templateData object to the asset helpers functions. This is for general-purpose HTML fragments / templates. When your template is uniquely tied to a specific view, you probably want to store it in the views folder, alongside the corresponding javascript file (same name but .html). See the topic \"Using Assets manager\") images Put here all the images that some of your views depends upon. json Put here any piece of STATIC json that any component might depends upon. sfx Put here all the .mp3 sounds that some of your views depends upon. styles Put here all the .css files that some of your views depends upon.","title":"/app/assets :"},{"location":"msgbus.html","text":"Message bus The principle of request-reply is at the core of web-applications since they exist. It is great but comes with some limitaions: Data displayed is not realtime: After your request for a data, if it changes server-side, your app., your user won't know until the next request. No server events: You server can only send something to your user when your user takes the initiative. No peer-to-peer events: a user app. cannot communicate with another user app. (at least not realtime, and not without using your back-end server wich has probably other things to do than route user-to-user messages). Attempts to work-around those inherent limitations exist, but usually involve polling (or long-polling) systems, which put a serious additional strain on your backend server. These are therefore always of a limited use, and not really scallable. Without questionning the request-reply model, the use of a realtime messagebus alongside can prove very complementary. This can be done with technologies which are now part of all major browsers, and mature enough to be deployed in secure, large, production environments. - Secure Websockets on top of HTTPS (same domain, same port 443), - WebWorkers : Running in a different browser thread than your js app, their data is inaccessible from it or from the console. - Server-side messaging brokers like Redis, RabbitMQ, MQTT, Active MQ and many other, offer stable, fast, scalable message routing and queuing. The messageBus plugin of Sparc : The message bus plugin of Sparc, together with it's server Node.js counterpart and a Redis-broker do exactly that : It basically allows your browser app. to connect to Redis Pub-Sub channels, server-side. It then becomes possible for your browser app. to send realtime messages to another user, or group of other users, or to any server-side back-end application or micro-service. But more interestingly, any server-side back-end application or micro-service can send realtime data or events to any browser app., user (maybe using your app in several browsers or tabs), or groups of users. The messageBus plugin for Sparc takes care of all communication gory details (Ronnections, keep-alive, auto-reconnection, subscriptions management,...). It offers a simplified yet powerfull API to tour app. Configuration enabled : Boolean When false, the messageBus is ...disabled ;-) pathToWorker\" : String This lib also uses a webworker which cannot be launched through the normal dependency system. This is the path to the worker script. Standard value is \"/core/libs/MessageBusWorker.js\" . protocol\" : The protocol part of the URL to the websocket server. Standard value is \"wss:\" . host\" : The host part of the URL to the websocket server. If absent or empty, the host will be extracted from the current browser's URL (same URL is a requirement often imposed by the browser, firewalls, proxies... anyway) port\" : The port part of the URL to the websocket server path\" : The (Where the HTTP-Upgrade will take place) connectTimeout : Float If the server remains silent at a connection attempt, connection will timeout after this many seconds. Caution : If autoReconnect is > 0, the Auto-reconnect will occur after connectTimeout + autoReconnect seconds, unless the door is immediately slammed in your face right away (then autoReconnect seconds). If your WSS server is hidden behind an Nginx (which you should really do in prod.), you should also pay attention to the Nginx parameters proxy_connect_timeout, proxy_send_timeout and proxy_read_timeout autoReconnect : Float If zero (or false): no auto-reconnect upon connection loss. Otherwise, the time, in seconds (decimals ok), before he FIRST reconnecting attempt. (ex: 5 seconds) autoReconnectTimeFactor : Float : on every successive reconnection failure, the auto-reconnect time is multiplied by this factor, to avoid reconnect-spamming when the WSS server is down. autoReconnectTimeMax : Float : The ceiling value for the auto-reconnect time. For example with autoReconnect:5, autoReconnectTimeFactor:2 , autoReconnectTimeMax:60 , attempts would occur at (connection loss) + 5sec, + 10sec, +20sec, +40sec then every minute ) autoReconnectJitterPercent : Float : If your websocket server goes down, all clients are loosing connection precisely at the same time. Therefore, their reconnection attempts will be synchronized, which is not what you want when you'll bring your WSS server back up ! If this parameter is non-zero, it represents the percentage of random \"jitter\" applied on the next reconnect time. For example: with a reconnect time of 30 sec, and autoReconnectJitterPercent:10 : the actual reconnection will occur between 28.5 and 31.5 seconds later. \"messageBus\":{ \"enabled\": true, \"pathToWorker\": \"/core/libs/MessageBusWorker.js\", \"protocol\": \"wss://\", \"port\": \"\", \"path\": \"/msgbus\", \"connectTimeout\": 5, \"autoReconnect\": 5, \"autoReconnectTimeFactor\": 1.3, \"autoReconnectTimeMax\": 30, \"autoReconnectJitterPercent\": 10 } Methods whenConnected callback function : Will be called when the connection is established. If called several times (normally with different callbacks), all the callbacks are queued and will be executed in order when the connection is ready. ifConnected callback function : Will be called if the connection is already established. If messageBus is not connected at the time of calling the method, the callback will never be used. executewhenConnectedQ You should not call this function directly. It is called internally when the connection becomes ready, to execute the 'TODO-List' created via whenConnected . subscribe : Asks the server to subscribe to Redis channels. It uses these arguments: chans Array of Strings : the list of channels you want to subscrie to. callBack function : Called when the server has answers the 'SUB' Action, sent by this method. The callback argument will be the json packet sent back by the server. In the case of a subscribe, it will contain the list of current subscriptions. Note about the subscription list your will receive: - If channels you requested are not in the list, it means they were rejected by the server. (The chan not allowed to this user). - If you see a channel you did not request, this can either mean that you had already subscribed to it before, or that you were automatically subscribed by the server upon connection (mandatory channels) getSubscriptions : Asks the server for currently subscribed channels. callBack function : Called when the server has answers the 'SUB' Action, sent by this method. The callback argument will be the json packet sent back by the server containing the list of current subscriptions. send : Publishes a message on a channel. It uses these arguments: chan : String The chan on which to publish. message : Object The Object you want to send as message. Caution : The object will be JSONified and is not binarry-safe. At this time, MessageBus has not provisions for binary data transmition. If you need to send binary data anyway, consider using Base64 encoding : Inefficient but will work. receiveFromWorker : Internal function that shall not be used by the app. receiveFromServer : Internal function that shall not be used by the app. Events Once enabled, the MessageBus will start to dispatch events on the document : MessageBus.Connected Dispatched when the bus connection to the back-end is established. The event object has nothing in 'detail' Caution : If you want to use this event, be ready to manage connection-lost => auto-reconnection(s) scenari ! On the other hand, if you just want to trigger some action when the connection is available, you can use the whenConnected callback registration method instead. MessageBus.Closed Dispatched when the bus connection was lost. The event object has nothing in 'detail' MessageBus.Message Dispatched when the bus has received a message from one of the subscribed channels. You'll find the message payload in event.detail It will look something like: { \"msg\":\"Hello world !\", \"chan\":\"nike_chan\" } About msg : In this example, the message is a simple String . If some json Object was sent, it comes already parsed for you. (thus as a javascript Object). MessageBus.[ACTION] Every action requested on the message bus via the propoer method (like 'SUB' for subscribe, 'UNSUB' for unsubscribe, etc), will trigger an event upon completion. the event name follows the name convention MessageBus.[ACTION] where [action] is the requested action. For example, If you cal the method getSubscriptions , it will launch an action 'SUBLST' towards the server. Upon completeion, an event MessageBus.SUBLST will be triggered. In this example, the event.detail will look like : [\"authorizer_chan\",\"ProposalUpdate_chan\",\"userchan_n642642\"]","title":"MessageBus lib"},{"location":"msgbus.html#message-bus","text":"The principle of request-reply is at the core of web-applications since they exist. It is great but comes with some limitaions: Data displayed is not realtime: After your request for a data, if it changes server-side, your app., your user won't know until the next request. No server events: You server can only send something to your user when your user takes the initiative. No peer-to-peer events: a user app. cannot communicate with another user app. (at least not realtime, and not without using your back-end server wich has probably other things to do than route user-to-user messages). Attempts to work-around those inherent limitations exist, but usually involve polling (or long-polling) systems, which put a serious additional strain on your backend server. These are therefore always of a limited use, and not really scallable. Without questionning the request-reply model, the use of a realtime messagebus alongside can prove very complementary. This can be done with technologies which are now part of all major browsers, and mature enough to be deployed in secure, large, production environments. - Secure Websockets on top of HTTPS (same domain, same port 443), - WebWorkers : Running in a different browser thread than your js app, their data is inaccessible from it or from the console. - Server-side messaging brokers like Redis, RabbitMQ, MQTT, Active MQ and many other, offer stable, fast, scalable message routing and queuing.","title":"Message bus"},{"location":"msgbus.html#the-messagebus-plugin-of-sparc","text":"The message bus plugin of Sparc, together with it's server Node.js counterpart and a Redis-broker do exactly that : It basically allows your browser app. to connect to Redis Pub-Sub channels, server-side. It then becomes possible for your browser app. to send realtime messages to another user, or group of other users, or to any server-side back-end application or micro-service. But more interestingly, any server-side back-end application or micro-service can send realtime data or events to any browser app., user (maybe using your app in several browsers or tabs), or groups of users. The messageBus plugin for Sparc takes care of all communication gory details (Ronnections, keep-alive, auto-reconnection, subscriptions management,...). It offers a simplified yet powerfull API to tour app.","title":"The messageBus plugin of Sparc :"},{"location":"msgbus.html#configuration","text":"enabled : Boolean When false, the messageBus is ...disabled ;-) pathToWorker\" : String This lib also uses a webworker which cannot be launched through the normal dependency system. This is the path to the worker script. Standard value is \"/core/libs/MessageBusWorker.js\" . protocol\" : The protocol part of the URL to the websocket server. Standard value is \"wss:\" . host\" : The host part of the URL to the websocket server. If absent or empty, the host will be extracted from the current browser's URL (same URL is a requirement often imposed by the browser, firewalls, proxies... anyway) port\" : The port part of the URL to the websocket server path\" : The (Where the HTTP-Upgrade will take place) connectTimeout : Float If the server remains silent at a connection attempt, connection will timeout after this many seconds. Caution : If autoReconnect is > 0, the Auto-reconnect will occur after connectTimeout + autoReconnect seconds, unless the door is immediately slammed in your face right away (then autoReconnect seconds). If your WSS server is hidden behind an Nginx (which you should really do in prod.), you should also pay attention to the Nginx parameters proxy_connect_timeout, proxy_send_timeout and proxy_read_timeout autoReconnect : Float If zero (or false): no auto-reconnect upon connection loss. Otherwise, the time, in seconds (decimals ok), before he FIRST reconnecting attempt. (ex: 5 seconds) autoReconnectTimeFactor : Float : on every successive reconnection failure, the auto-reconnect time is multiplied by this factor, to avoid reconnect-spamming when the WSS server is down. autoReconnectTimeMax : Float : The ceiling value for the auto-reconnect time. For example with autoReconnect:5, autoReconnectTimeFactor:2 , autoReconnectTimeMax:60 , attempts would occur at (connection loss) + 5sec, + 10sec, +20sec, +40sec then every minute ) autoReconnectJitterPercent : Float : If your websocket server goes down, all clients are loosing connection precisely at the same time. Therefore, their reconnection attempts will be synchronized, which is not what you want when you'll bring your WSS server back up ! If this parameter is non-zero, it represents the percentage of random \"jitter\" applied on the next reconnect time. For example: with a reconnect time of 30 sec, and autoReconnectJitterPercent:10 : the actual reconnection will occur between 28.5 and 31.5 seconds later. \"messageBus\":{ \"enabled\": true, \"pathToWorker\": \"/core/libs/MessageBusWorker.js\", \"protocol\": \"wss://\", \"port\": \"\", \"path\": \"/msgbus\", \"connectTimeout\": 5, \"autoReconnect\": 5, \"autoReconnectTimeFactor\": 1.3, \"autoReconnectTimeMax\": 30, \"autoReconnectJitterPercent\": 10 }","title":"Configuration"},{"location":"msgbus.html#methods","text":"whenConnected callback function : Will be called when the connection is established. If called several times (normally with different callbacks), all the callbacks are queued and will be executed in order when the connection is ready. ifConnected callback function : Will be called if the connection is already established. If messageBus is not connected at the time of calling the method, the callback will never be used. executewhenConnectedQ You should not call this function directly. It is called internally when the connection becomes ready, to execute the 'TODO-List' created via whenConnected . subscribe : Asks the server to subscribe to Redis channels. It uses these arguments: chans Array of Strings : the list of channels you want to subscrie to. callBack function : Called when the server has answers the 'SUB' Action, sent by this method. The callback argument will be the json packet sent back by the server. In the case of a subscribe, it will contain the list of current subscriptions. Note about the subscription list your will receive: - If channels you requested are not in the list, it means they were rejected by the server. (The chan not allowed to this user). - If you see a channel you did not request, this can either mean that you had already subscribed to it before, or that you were automatically subscribed by the server upon connection (mandatory channels) getSubscriptions : Asks the server for currently subscribed channels. callBack function : Called when the server has answers the 'SUB' Action, sent by this method. The callback argument will be the json packet sent back by the server containing the list of current subscriptions. send : Publishes a message on a channel. It uses these arguments: chan : String The chan on which to publish. message : Object The Object you want to send as message. Caution : The object will be JSONified and is not binarry-safe. At this time, MessageBus has not provisions for binary data transmition. If you need to send binary data anyway, consider using Base64 encoding : Inefficient but will work. receiveFromWorker : Internal function that shall not be used by the app. receiveFromServer : Internal function that shall not be used by the app.","title":"Methods"},{"location":"msgbus.html#events","text":"Once enabled, the MessageBus will start to dispatch events on the document : MessageBus.Connected Dispatched when the bus connection to the back-end is established. The event object has nothing in 'detail' Caution : If you want to use this event, be ready to manage connection-lost => auto-reconnection(s) scenari ! On the other hand, if you just want to trigger some action when the connection is available, you can use the whenConnected callback registration method instead. MessageBus.Closed Dispatched when the bus connection was lost. The event object has nothing in 'detail' MessageBus.Message Dispatched when the bus has received a message from one of the subscribed channels. You'll find the message payload in event.detail It will look something like: { \"msg\":\"Hello world !\", \"chan\":\"nike_chan\" } About msg : In this example, the message is a simple String . If some json Object was sent, it comes already parsed for you. (thus as a javascript Object). MessageBus.[ACTION] Every action requested on the message bus via the propoer method (like 'SUB' for subscribe, 'UNSUB' for unsubscribe, etc), will trigger an event upon completion. the event name follows the name convention MessageBus.[ACTION] where [action] is the requested action. For example, If you cal the method getSubscriptions , it will launch an action 'SUBLST' towards the server. Upon completeion, an event MessageBus.SUBLST will be triggered. In this example, the event.detail will look like : [\"authorizer_chan\",\"ProposalUpdate_chan\",\"userchan_n642642\"]","title":"Events"},{"location":"mvc.html","text":"4. Write your Models, View and Controllers Models Quick reminder : Models implement the application's dynamic data structures, independent of the user interface. They directly manage the data, provide methods that help implement the logic and business rules of the application. On the client side, they also implement the exchanges with the Back-end (which -in turn- usually talks with a DB of any kind). In Sparc (like in most MVC frameworks), your models are javascript scripts that must implement a class which inherit from the model base-class (in core/baseClasses ) If you want some \"universal\" methods to help your models low-level with your servers (like data-caching, lazy-loading, protocols mgt...), a good place to put them is in the model base-class. Views Quick reminder : Views implement any representation of information in text, tables, diagrams, etc. Multiple views of the same information are possible. Their algorithmic should concern only the (graphical) presentation of data. To implement a view client-side, you need two parts: some HTML, and some javascript that helps shaping it, and integrate data in it. In Sparc (again like in most MVC frameworks), your views are javascript scripts that must implement a class which inherit from the view base-class (in core/baseClasses ) About the HTML (or template), two approaches are possible (your choice) : Integrated views : the HTML is embed directly within your javascript code. Usually you would use template literals , by means of backtits, to avoid cumbresome concatenation of strings. Splitted script-HTML : If the HTML fragment is large, it is often more convenient to store it in a separate file, stored alongside the script. Sparc lets you do this easily, by using its internal dependency mechanism. (See the 'views' attribute of the controllers config). Both approaches can of course be combined in a single app, or even in a single view. A word about templating: When embedding HTML inside your javascript, you can use template literals. In other words, your HTML can include javascript expressions such as ${x+5} . They will be evaluated by javascript, using variables in the current scope, and replaced by their result. So what about templating in a \"splitted script-HTML\" context ? Templates are managed by the Assets manager, and it provides methods to integrate your view template into the existing DOM (namely: replaceByView, appendByView, prependByView ). One cool feature of these methods is that they accept an argument called templateData . templateData must be a key-value object, where the keys are matching your template variables. If present, it will trigger a genuine javascript-level \"template literals\" interpretation of your template. No new fancy templating engine dependency (your templates are agnostic), no new syntax to learn, 100% backward and forward compatibility with vanilla JS ! Fool-proof templating... As explained above, templates interpretation use the genuine vanilla-javascript internal interpretation, but with a small addition: In pure javascript, if an expression in the template is wrong (syntax or unknown variable), your script will crash. If you use the methods mentionned above, a pre-flight-check is performed on your template pefore handing it to interpretation: Any wrong expression will be suppressed, a clear warning will be issued at the console, and your template will not crash your view ! A word about the path to your templates: When using an external template for a view, you need to include your template as a dependecy of that view. There are to possible places for your templates: some people prefer to have the view class (.js file) alongside with it's corresponding template (usually same name in .html). This means it will be located somewhere below /app/views When that is your case, you need to use the views section of the assets dependency block, that assumes this particular path, keeping your config small and readable (only view name, or short path relative to /app/views ). When using Assets helper methods, use those ending with 'View' (namely: replaceByView, appendByView, prependByView ) Other people prefer to regroup all templates in one place, separated vrom the view classes. In that case, you can place them in the assets store at /app/assets/html When that is your case, you need to use the html section of the assets dependency block, that assumes this particular path. When using Assets helper methods, you then use those ending with 'Html' (namely: replaceByHtml, appendByHtml, prependByHtml ) This difference exists because for html , the assets manager (like for any other asset-type) can also cope with any other relative of absolute path or even with external http(s) urls. Controllers Quick reminder : Controllers accept user inputs and converts them to commands (methods) for the model or view. It is the bridge between views-logic (graphical behavior), and models-logic (business-logic). In Sparc (again like in most MVC frameworks), your controllers are javascript scripts that must implement a class which inherit from the controller base-class (in core/baseClasses ) Important : Controller methods are called with a single argument, which is an object containing any number of named paramerters. So a method looks like : myMethod(args){ if(args.id != 0) ... if(args.coords.x>100) } controllers config. In Sparc, each controller is accompagnied by a mandatory configuration file. It is a json file (.json) placed alongside your controller script (.js) file. It is mandatory . A controller without config. will not be loaded by the router. Everything it contains is optional, but the file and sections must be present. A minimal controller config. looks like this: { \"routes\": [ ], \"models\": [ \"myModel\" ], \"views\": [ \"myView\" ], \"dependencies\": [ ], \"assets\": { \"fonts\" : [ ], \"styles\": [ ], \"html\": [ ], \"views\": [ ], \"images\": [ {\"name\":\"logo.jpg\"} ], \"sfx\": [ ], \"json\": [ ] } } The controller config. defines: This controller nested routes This Controller dependencies: Models dependencies Views dependencies Other dependencies (libs, thirdparties,...) Assets dependencies (images, styles, fonts, sounds, view-templates, other-html-fragments, static-json-files) Nested routess: They use exactly the same syntax that the op-level routes (see \"Understand routing\" ) But the url parts are automatically prefixed with the part of the current URL which has led to this controller. For example: Consider the top-level route definition: { \"url\": \"/module2/user:uid\", \"role\": [\"*\"], \"controller\" : \"/module2/userCtrl\", \"method\" : \"userView\" }, Now say that \"/module2/userCtrl.json\" goes like: { \"routes\":[ { \"url\": \"/edit\", \"role\": [\"admin\"], \"controller\" : \"/module2/userEditorCtrl\", \"method\" : \"launchEditor\", }, ], ... } If and URL like https://mydomain.com/module2/user/642/edit is presented to the router by an admin-user , it will end-up in the controller /module2/userEditorCtrl . This is because the router was first directed toward the controller /module2/userCtrl , but it then added the new rule like \"url\" : \"/module2/user/642/edit\" (notice how the already-matched part is prepended). As this new (local) route matches better than the previous one attempted, it wins. Controller dependencies: Each of the keys models , views and dependencies , expects an array of script names (with or withoout the '.js'). They can include a path part (like \"/persons/employees\" ) which is respectively below /app/models , /app/views for models and views , and directly below the site root for dependencies . As you can see, the dependencies is used for any script which is not a model, nor a view. You can specify values like \"/app/libs/xxx\" for your own app-related libraries, \"/app/thirdparty/xxx\" for any thirdparty scripts, or anything somewhere else on your server, or even \"https://code.jquery.com/jquery-3.6.1.slim.min.js\" to get an external script (like from a CDN).","title":"4. Write your MVC components"},{"location":"mvc.html#4-write-your-models-view-and-controllers","text":"","title":"4. Write your Models, View and Controllers"},{"location":"mvc.html#models","text":"Quick reminder : Models implement the application's dynamic data structures, independent of the user interface. They directly manage the data, provide methods that help implement the logic and business rules of the application. On the client side, they also implement the exchanges with the Back-end (which -in turn- usually talks with a DB of any kind). In Sparc (like in most MVC frameworks), your models are javascript scripts that must implement a class which inherit from the model base-class (in core/baseClasses ) If you want some \"universal\" methods to help your models low-level with your servers (like data-caching, lazy-loading, protocols mgt...), a good place to put them is in the model base-class.","title":"Models"},{"location":"mvc.html#views","text":"Quick reminder : Views implement any representation of information in text, tables, diagrams, etc. Multiple views of the same information are possible. Their algorithmic should concern only the (graphical) presentation of data. To implement a view client-side, you need two parts: some HTML, and some javascript that helps shaping it, and integrate data in it. In Sparc (again like in most MVC frameworks), your views are javascript scripts that must implement a class which inherit from the view base-class (in core/baseClasses ) About the HTML (or template), two approaches are possible (your choice) : Integrated views : the HTML is embed directly within your javascript code. Usually you would use template literals , by means of backtits, to avoid cumbresome concatenation of strings. Splitted script-HTML : If the HTML fragment is large, it is often more convenient to store it in a separate file, stored alongside the script. Sparc lets you do this easily, by using its internal dependency mechanism. (See the 'views' attribute of the controllers config). Both approaches can of course be combined in a single app, or even in a single view. A word about templating: When embedding HTML inside your javascript, you can use template literals. In other words, your HTML can include javascript expressions such as ${x+5} . They will be evaluated by javascript, using variables in the current scope, and replaced by their result. So what about templating in a \"splitted script-HTML\" context ? Templates are managed by the Assets manager, and it provides methods to integrate your view template into the existing DOM (namely: replaceByView, appendByView, prependByView ). One cool feature of these methods is that they accept an argument called templateData . templateData must be a key-value object, where the keys are matching your template variables. If present, it will trigger a genuine javascript-level \"template literals\" interpretation of your template. No new fancy templating engine dependency (your templates are agnostic), no new syntax to learn, 100% backward and forward compatibility with vanilla JS ! Fool-proof templating... As explained above, templates interpretation use the genuine vanilla-javascript internal interpretation, but with a small addition: In pure javascript, if an expression in the template is wrong (syntax or unknown variable), your script will crash. If you use the methods mentionned above, a pre-flight-check is performed on your template pefore handing it to interpretation: Any wrong expression will be suppressed, a clear warning will be issued at the console, and your template will not crash your view ! A word about the path to your templates: When using an external template for a view, you need to include your template as a dependecy of that view. There are to possible places for your templates: some people prefer to have the view class (.js file) alongside with it's corresponding template (usually same name in .html). This means it will be located somewhere below /app/views When that is your case, you need to use the views section of the assets dependency block, that assumes this particular path, keeping your config small and readable (only view name, or short path relative to /app/views ). When using Assets helper methods, use those ending with 'View' (namely: replaceByView, appendByView, prependByView ) Other people prefer to regroup all templates in one place, separated vrom the view classes. In that case, you can place them in the assets store at /app/assets/html When that is your case, you need to use the html section of the assets dependency block, that assumes this particular path. When using Assets helper methods, you then use those ending with 'Html' (namely: replaceByHtml, appendByHtml, prependByHtml ) This difference exists because for html , the assets manager (like for any other asset-type) can also cope with any other relative of absolute path or even with external http(s) urls.","title":"Views"},{"location":"mvc.html#controllers","text":"Quick reminder : Controllers accept user inputs and converts them to commands (methods) for the model or view. It is the bridge between views-logic (graphical behavior), and models-logic (business-logic). In Sparc (again like in most MVC frameworks), your controllers are javascript scripts that must implement a class which inherit from the controller base-class (in core/baseClasses ) Important : Controller methods are called with a single argument, which is an object containing any number of named paramerters. So a method looks like : myMethod(args){ if(args.id != 0) ... if(args.coords.x>100) }","title":"Controllers"},{"location":"mvc.html#controllers-config","text":"In Sparc, each controller is accompagnied by a mandatory configuration file. It is a json file (.json) placed alongside your controller script (.js) file. It is mandatory . A controller without config. will not be loaded by the router. Everything it contains is optional, but the file and sections must be present. A minimal controller config. looks like this: { \"routes\": [ ], \"models\": [ \"myModel\" ], \"views\": [ \"myView\" ], \"dependencies\": [ ], \"assets\": { \"fonts\" : [ ], \"styles\": [ ], \"html\": [ ], \"views\": [ ], \"images\": [ {\"name\":\"logo.jpg\"} ], \"sfx\": [ ], \"json\": [ ] } } The controller config. defines: This controller nested routes This Controller dependencies: Models dependencies Views dependencies Other dependencies (libs, thirdparties,...) Assets dependencies (images, styles, fonts, sounds, view-templates, other-html-fragments, static-json-files)","title":"controllers config."},{"location":"mvc.html#nested-routess","text":"They use exactly the same syntax that the op-level routes (see \"Understand routing\" ) But the url parts are automatically prefixed with the part of the current URL which has led to this controller. For example: Consider the top-level route definition: { \"url\": \"/module2/user:uid\", \"role\": [\"*\"], \"controller\" : \"/module2/userCtrl\", \"method\" : \"userView\" }, Now say that \"/module2/userCtrl.json\" goes like: { \"routes\":[ { \"url\": \"/edit\", \"role\": [\"admin\"], \"controller\" : \"/module2/userEditorCtrl\", \"method\" : \"launchEditor\", }, ], ... } If and URL like https://mydomain.com/module2/user/642/edit is presented to the router by an admin-user , it will end-up in the controller /module2/userEditorCtrl . This is because the router was first directed toward the controller /module2/userCtrl , but it then added the new rule like \"url\" : \"/module2/user/642/edit\" (notice how the already-matched part is prepended). As this new (local) route matches better than the previous one attempted, it wins.","title":"Nested routess:"},{"location":"mvc.html#controller-dependencies","text":"Each of the keys models , views and dependencies , expects an array of script names (with or withoout the '.js'). They can include a path part (like \"/persons/employees\" ) which is respectively below /app/models , /app/views for models and views , and directly below the site root for dependencies . As you can see, the dependencies is used for any script which is not a model, nor a view. You can specify values like \"/app/libs/xxx\" for your own app-related libraries, \"/app/thirdparty/xxx\" for any thirdparty scripts, or anything somewhere else on your server, or even \"https://code.jquery.com/jquery-3.6.1.slim.min.js\" to get an external script (like from a CDN).","title":"Controller dependencies:"},{"location":"routing.html","text":"3. Understand the routing Routes delegations: Routes must be defined in the \"baseRoutes.json\" file in the the application's config. However, when you have a large application, and therefore many routes, managing them all in a single file can become tedious. Therefore Sparc allows for route delegation, by having controller's configuration files deined their own (sub-) routes. A controller can only use URLs beginning by the URL which lead to him. (hence the \"delegation\" aspect much like DNS zones). When analysing the Browser's URL, the router will try all the known routes at that moment (which changes with delegation when new controllers are loaded). The route-findging algorithm goes as this: 1. Try to match the current URL againts each of all known routes. 2. When the URL matches, check that the user role matches the route role too, unless the route role is '*' (meaning everyone) 3. When something doesn not match, discard the route. 4. When both are ok, give this route a score which is the number of matching parts , then keep it as candidate. 5. When all known routes are exhausted, the candidate with the highest score is used. The routing algorithm then goes as this: 1. When the best route is found (see above), the router loads the config of the corresponding controller. 2. It then adds the routes eventually defined by that controller config. to the global routes list. 3. It now retries to route the URL, to see of some of these new routes give a better score. If yes, it recursively goes back to step 1. 4. When the route does not change anymore, we have found the best possible route, delegations included. It is now time to : 1. Instantiate the controller. 2. Choose the proper method: - If a method was specified in the route definition (see below), use it. - If not then use the last part of the url as the method name. 3. Build a parameters object conatining : - Static parameters found in the route definition (see below). - Dynamic parameters extracted (and enventually regexp-validated) from the URL Each part of the object above is described separately below : URL matching url : String [Mandatory] Is the URL pattern that the router will try to match the current browser's URL against. It can contain static parts, and dynamic parts (for parameters). For static parts (like \"/module1/user\" in the example above), the router will try to match it 'as is', at the right place. For dynamic parts (like :name or like \":uid(\\d+)\" in the example above), the router will take everything until the next '/' , or until the end of the URL. The string after the ':' will be used as parameter name. The parameter value (transmitted to the controller's method) will be the actual string found at this place of the URL. If the parameter name is followed by brackets, their content will be used as a regular expression to validate the parameter. Failure to validate a parameter leads to this route not matching. Roles matching role : String [Mandatory] Is the role to match with the current user role. Specifying '*' matches any user role. Controller selection controller : String [Mandatory] Is the controller's relative path inside the controllers basePath. This field is mandatory, unless the exturl is used instead. Method selection method : String [optional] If specified: the name of the method to call in that controller. In absent, the last segment of the URL will be used. Method parameters params : String [optional] An key:value object of static parameters passed to the method, alongside eventual dynamic parameters. Caution : if the same key is found as dynamic and static parameter, the static value will prevail . Special routing cases: The default route At least one route shall have as url the special value \"!defaultroute\" This route is used as the last-ressort route, when no matches could be found. This is the equivalent of a server 404 page (But there is no server, hence no status code here) The other parameters are as usual, no dynamic parameters are of-course allowed. You could have different default pages for different roles if you want (if it make sense for you, otherwise just use one default route with \"role\" : \"*\" ) External URLs If exturl is used instead of controller , then this route is considered to be external to the application and the user will be redirected to it. The role can be used in conjuction with it, but method and params are meaningless.","title":"3. Understand the routing"},{"location":"routing.html#3-understand-the-routing","text":"Routes delegations: Routes must be defined in the \"baseRoutes.json\" file in the the application's config. However, when you have a large application, and therefore many routes, managing them all in a single file can become tedious. Therefore Sparc allows for route delegation, by having controller's configuration files deined their own (sub-) routes. A controller can only use URLs beginning by the URL which lead to him. (hence the \"delegation\" aspect much like DNS zones). When analysing the Browser's URL, the router will try all the known routes at that moment (which changes with delegation when new controllers are loaded). The route-findging algorithm goes as this: 1. Try to match the current URL againts each of all known routes. 2. When the URL matches, check that the user role matches the route role too, unless the route role is '*' (meaning everyone) 3. When something doesn not match, discard the route. 4. When both are ok, give this route a score which is the number of matching parts , then keep it as candidate. 5. When all known routes are exhausted, the candidate with the highest score is used. The routing algorithm then goes as this: 1. When the best route is found (see above), the router loads the config of the corresponding controller. 2. It then adds the routes eventually defined by that controller config. to the global routes list. 3. It now retries to route the URL, to see of some of these new routes give a better score. If yes, it recursively goes back to step 1. 4. When the route does not change anymore, we have found the best possible route, delegations included. It is now time to : 1. Instantiate the controller. 2. Choose the proper method: - If a method was specified in the route definition (see below), use it. - If not then use the last part of the url as the method name. 3. Build a parameters object conatining : - Static parameters found in the route definition (see below). - Dynamic parameters extracted (and enventually regexp-validated) from the URL Each part of the object above is described separately below :","title":"3.  Understand the routing"},{"location":"routing.html#url-matching","text":"url : String [Mandatory] Is the URL pattern that the router will try to match the current browser's URL against. It can contain static parts, and dynamic parts (for parameters). For static parts (like \"/module1/user\" in the example above), the router will try to match it 'as is', at the right place. For dynamic parts (like :name or like \":uid(\\d+)\" in the example above), the router will take everything until the next '/' , or until the end of the URL. The string after the ':' will be used as parameter name. The parameter value (transmitted to the controller's method) will be the actual string found at this place of the URL. If the parameter name is followed by brackets, their content will be used as a regular expression to validate the parameter. Failure to validate a parameter leads to this route not matching.","title":"URL matching"},{"location":"routing.html#roles-matching","text":"role : String [Mandatory] Is the role to match with the current user role. Specifying '*' matches any user role.","title":"Roles matching"},{"location":"routing.html#controller-selection","text":"controller : String [Mandatory] Is the controller's relative path inside the controllers basePath. This field is mandatory, unless the exturl is used instead.","title":"Controller selection"},{"location":"routing.html#method-selection","text":"method : String [optional] If specified: the name of the method to call in that controller. In absent, the last segment of the URL will be used.","title":"Method selection"},{"location":"routing.html#method-parameters","text":"params : String [optional] An key:value object of static parameters passed to the method, alongside eventual dynamic parameters. Caution : if the same key is found as dynamic and static parameter, the static value will prevail .","title":"Method parameters"},{"location":"routing.html#special-routing-cases","text":"","title":"Special routing cases:"},{"location":"routing.html#the-default-route","text":"At least one route shall have as url the special value \"!defaultroute\" This route is used as the last-ressort route, when no matches could be found. This is the equivalent of a server 404 page (But there is no server, hence no status code here) The other parameters are as usual, no dynamic parameters are of-course allowed. You could have different default pages for different roles if you want (if it make sense for you, otherwise just use one default route with \"role\" : \"*\" )","title":"The default route"},{"location":"routing.html#external-urls","text":"If exturl is used instead of controller , then this route is considered to be external to the application and the user will be redirected to it. The role can be used in conjuction with it, but method and params are meaningless.","title":"External URLs"}]}