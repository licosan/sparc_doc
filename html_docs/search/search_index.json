{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to SPARC ___ ____ __ ____ ___ / __)( _ \\ /__\\ ( _ \\ / __) ___\\__ \\ )___//(__)\\ ) /( (__ (_______/(__) (__)(__)(_)\\_) \\___) Single Page Applications Rational Code Sparc is a javascript MVC framework for Single Page Applications Sparc main objectives MVC Sparc is a framework with the MVC architectural pattern at its center. MVC has been used exptensively for traditional web application, on the server side, for decades in every possible programming language: for example, think about Ruby-on-Rails in Ruby, Django in Python, CodeIgniter / Zend in PHP, Spring / JSF / Struts in Java just to name a few. With the advent of Single Page Applications, the front-end (browser) side of applications now also needs an architectural pattern that can structure large amounts of code, and MVC fits just as well. Models, Views, Controllers and Routing on the client-side (browser) have the same purpose as they have on the server-side. Sparc implements a corresponding file structure for your scripts (models, View & Controllers), plus templates and configuration files. Be aware: You should be familliar with the MVC pattern before digging any further into this doc. You'll find plenty of cool introductions one the web if you think you need it. Truly detached Your application boots, and serves all its different URLs without the help of a backend server. Only static files are used. Backend server is only there to answer to AJAX requests. Small footprint, fast serving Loads only what you need, just whene you need it: Scripts and Assets ( like images, fonts, css, ...) are loaded only once (clever non-browser caching), only when needed (lazy-loading). Clever Loading Scripts can depend on other scripts and on Assets. Define your dependency trees in clear JSON files, and Sparc will make sure everything your script needs is loaded beforehand. It will also optimize the loading by loading several things in parallel, but only where there is no risk to break a dependency. Powerful URL Routing Sparc lets you define route patterns in readable JSON files. Routes can be nested: a controller can redefine its own scope of routes. The URL patterns can use Regular Expressions, to extract named parameters. Methods can be specified, or not. A best match strategy is used when several routes are matching the URL + User role combination. Forward / Back buttons and internal links are intercepted to avoid any unwanted reload and the user is warned before exiting the application. External error logging Javascript Warnings and Errors in the console (from your code or directly from the browser) can trigger a fire-and-forget Ajax to any external service to have them store in a database, sent formated emails, etc... The error-level, the stack-trace and all relevant informations (like url, user, user-role) are included in the Json.","title":"Home"},{"location":"index.html#welcome-to-sparc","text":"___ ____ __ ____ ___ / __)( _ \\ /__\\ ( _ \\ / __) ___\\__ \\ )___//(__)\\ ) /( (__ (_______/(__) (__)(__)(_)\\_) \\___) Single Page Applications Rational Code","title":"Welcome to SPARC"},{"location":"index.html#sparc-is-a-javascript-mvc-framework-for-single-page-applications","text":"","title":"Sparc is a javascript MVC framework for Single Page Applications"},{"location":"index.html#sparc-main-objectives","text":"MVC Sparc is a framework with the MVC architectural pattern at its center. MVC has been used exptensively for traditional web application, on the server side, for decades in every possible programming language: for example, think about Ruby-on-Rails in Ruby, Django in Python, CodeIgniter / Zend in PHP, Spring / JSF / Struts in Java just to name a few. With the advent of Single Page Applications, the front-end (browser) side of applications now also needs an architectural pattern that can structure large amounts of code, and MVC fits just as well. Models, Views, Controllers and Routing on the client-side (browser) have the same purpose as they have on the server-side. Sparc implements a corresponding file structure for your scripts (models, View & Controllers), plus templates and configuration files. Be aware: You should be familliar with the MVC pattern before digging any further into this doc. You'll find plenty of cool introductions one the web if you think you need it. Truly detached Your application boots, and serves all its different URLs without the help of a backend server. Only static files are used. Backend server is only there to answer to AJAX requests. Small footprint, fast serving Loads only what you need, just whene you need it: Scripts and Assets ( like images, fonts, css, ...) are loaded only once (clever non-browser caching), only when needed (lazy-loading). Clever Loading Scripts can depend on other scripts and on Assets. Define your dependency trees in clear JSON files, and Sparc will make sure everything your script needs is loaded beforehand. It will also optimize the loading by loading several things in parallel, but only where there is no risk to break a dependency. Powerful URL Routing Sparc lets you define route patterns in readable JSON files. Routes can be nested: a controller can redefine its own scope of routes. The URL patterns can use Regular Expressions, to extract named parameters. Methods can be specified, or not. A best match strategy is used when several routes are matching the URL + User role combination. Forward / Back buttons and internal links are intercepted to avoid any unwanted reload and the user is warned before exiting the application. External error logging Javascript Warnings and Errors in the console (from your code or directly from the browser) can trigger a fire-and-forget Ajax to any external service to have them store in a database, sent formated emails, etc... The error-level, the stack-trace and all relevant informations (like url, user, user-role) are included in the Json.","title":"Sparc main objectives"},{"location":"app_config.html","text":"Application configuration There are two Json files located in /app/config : appConfig.json : General configuration parameters for this application. baseRoutes.json : Defines the top-level routes General configuration This configuration Json file contains one separated block for every configurable core library. Logger config (key: \"logger\") enabled : Boolean When false, the logger is ...disabled ;-) Importantly, that means that the browser console remains the original one. levels : Array Containing either 'warn', 'error' or both. postUrl : String The Url where the Json of the error will be posted Example config block: \"logger\": { \"enabled\": true, \"levels\": [\"warn\", \"err\"], \"postUrl\": \"https://mydomain.com/log2mail.php\" }, Example Error posted: \"level\":\"WARNING\", \"message\":\"In template employeeViews/EmployeeView.html, badvariable is not defined !\", \"user\":\"nike\", \"url\":\"https://mydomain.com/employees\", \"appName\":\"MyApp 2.0\", \"stacktrace\":[ [\"processTemplate\",\"Assets.js\",[\"221\",\"25\"]], [\"replaceByHtml\",\"Assets.js\",[\"241\",\"66\"]], [\"loadHtml\",\"Assets.js\",[\"182\",\"56\"]], [\"replaceByHtml\",\"Assets.js\",[\"246\",\"14\"]], [\"...all the way up to Sparc-core...\"] ] Assets manager config basePath : String The path where all assets are stored Example config block: \"assets\": { \"basePath\": \"/app/assets/\" }, Router config getRoleFrom : String This is a String that represents a function or method . It Will be called by the router to get the role used in routing. Standard value is \"app.User.getRole\" , which uses the (early loaded) User class that you can override (see \"Custom User class\" below) Caution : This is needed early in the routing process, and therefore should be able to answer right away (no promise). If this string does not represent a callable, it is used as a plain string value. (useful for no-login-dev-mode) controllersPath : String The root path of controllers. Standard value is \"/app/controllers\" *. modelsPath : String The root path of models. Standard value is \"/app/models\" *. viewsPath : String The root path of views. Standard value is \"/app/views\" *. Example config block: \"router\": { \"getRoleFrom\": \"app.User.getRole\", \"controllersPath\": \"/app/controllers/\", \"modelsPath\": \"/app/models/\", \"viewsPath\": \"/app/views/\" }, Custom User class String This is the name (without .js) of the file containing your override of the User class. Caution : The file cannot be called \"User\", as the loader would consider this class is already loaded. (the Baseclass is indeed) Look at the base class at /core/baseClasses/User.js to see the interface. Here is a typical example : 'use strict' app.LoadedClasses.User = class extends app.LoadedClasses.User { constructor(){ super(); } checkAuthenticated(callBack){ // Call an service to know if we are logged in fetch('https://mydomain/checkAuthenticated?'+crypto.randomUUID(),{ method: 'GET', credentials: 'include' }) .then(response => response.json()) .then(resp => { if(resp.success){ this.isAuthenticated = resp.data.isAuthenticated; if(resp.data.isAuthenticated) { // Meanwhile get user infos this.userInfo = resp.data.userInfo; callBack(); } else { console.warn('User was not authenticated !'); this.authUrl = resp.data.authUrl; callBack(); // sparCore defaults is call gotoLogin below } } else { console.error('Server error calling checkAuthenticated !?') } }); } gotoLogin(){ // Redirect, or call a service, or show a login button... document.location.href = 'https://mydomain.com/login.php'; } } Message Bus config This the configuration of the messagebus module. As messageBus uses Websocket-based communication, a lot of this config. has to do with WSS. enabled : Boolean When false, the messageBus is ...disabled ;-) pathToWorker\" : String This lib also uses a webworker which cannot be launched through the normal dependency system. This is the path to the worker script. Standard value is \"/core/libs/MessageBusWorker.js\" . protocol\" : The protocol part of the URL to the websocket server. Standard value is \"wss:\" . host\" : The host part of the URL to the websocket server. If absent or empty, the host will be extracted from the current browser's URL (same URL is a requirement often imposed by the browser, firewalls, proxies... anyway) port\" : The port part of the URL to the websocket server path\" : The (Where the HTTP-Upgrade will take place) connectTimeout : Float If the server remains silent at a connection attempt, connection will timeout after this many seconds. Caution : If autoReconnect is > 0, the Auto-reconnect will occur after connectTimeout + autoReconnect seconds, unless the door is immediately slammed in your face right away (then autoReconnect seconds). If your WSS server is hidden behind an Nginx (which you should really do in prod.), you should also pay attention to the Nginx parameters proxy_connect_timeout, proxy_send_timeout and proxy_read_timeout autoReconnect : Float If zero (or false): no auto-reconnect upon connection loss. Otherwise, the time, in seconds (decimals ok), before he FIRST reconnecting attempt. (ex: 5 seconds) autoReconnectTimeFactor : Float : on every successive reconnection failure, the auto-reconnect time is multiplied by this factor, to avoid reconnect-spamming when the WSS server is down. autoReconnectTimeMax : Float : The ceiling value for the auto-reconnect time. For example with autoReconnect:5, autoReconnectTimeFactor:2 , autoReconnectTimeMax:60 , attempts would occur at (connection loss) + 5sec, + 10sec, +20sec, +40sec then every minute ) autoReconnectJitterPercent : Float : If your websocket server goes down, all clients are loosing connection precisely at the same time. Therefore, their reconnection attempts will be synchronized, which is not what you want when you'll bring your WSS server back up ! If this parameter is non-zero, it represents the percentage of random \"jitter\" applied on the next reconnect time. For example: with a reconnect time of 30 sec, and autoReconnectJitterPercent:10 : the actual reconnection will occur between 28.5 and 31.5 seconds later. \"messageBus\":{ \"enabled\": true, \"pathToWorker\": \"/core/libs/MessageBusWorker.js\", \"protocol\": \"wss://\", \"port\": \"\", \"path\": \"/msgbus\", \"connectTimeout\": 5, \"autoReconnect\": 5, \"autoReconnectTimeFactor\": 1.3, \"autoReconnectTimeMax\": 30, \"autoReconnectJitterPercent\": 10 } Top level routes definition Here are the definitions of the top-level routes used by the router. This file contains a Json Array of route objects such as for example : { \"url\": \"/module1/user:uid(\\\\d+)\", \"role\": \"theboss\", \"controller\" : \"/common/User/UserCtrl\", \"method\": \"userMod\" }, If you have tons of routes and want to keep this file reasonable, you can delegate \"sub-routes\" at each controller level. See \"Understanding the routing\" section for more details.","title":"Configure your app"},{"location":"app_config.html#application-configuration","text":"There are two Json files located in /app/config : appConfig.json : General configuration parameters for this application. baseRoutes.json : Defines the top-level routes","title":"Application configuration"},{"location":"app_config.html#general-configuration","text":"This configuration Json file contains one separated block for every configurable core library.","title":"General configuration"},{"location":"app_config.html#logger-config-key-logger","text":"enabled : Boolean When false, the logger is ...disabled ;-) Importantly, that means that the browser console remains the original one. levels : Array Containing either 'warn', 'error' or both. postUrl : String The Url where the Json of the error will be posted Example config block: \"logger\": { \"enabled\": true, \"levels\": [\"warn\", \"err\"], \"postUrl\": \"https://mydomain.com/log2mail.php\" }, Example Error posted: \"level\":\"WARNING\", \"message\":\"In template employeeViews/EmployeeView.html, badvariable is not defined !\", \"user\":\"nike\", \"url\":\"https://mydomain.com/employees\", \"appName\":\"MyApp 2.0\", \"stacktrace\":[ [\"processTemplate\",\"Assets.js\",[\"221\",\"25\"]], [\"replaceByHtml\",\"Assets.js\",[\"241\",\"66\"]], [\"loadHtml\",\"Assets.js\",[\"182\",\"56\"]], [\"replaceByHtml\",\"Assets.js\",[\"246\",\"14\"]], [\"...all the way up to Sparc-core...\"] ]","title":"Logger config (key: \"logger\")"},{"location":"app_config.html#assets-manager-config","text":"basePath : String The path where all assets are stored Example config block: \"assets\": { \"basePath\": \"/app/assets/\" },","title":"Assets manager config"},{"location":"app_config.html#router-config","text":"getRoleFrom : String This is a String that represents a function or method . It Will be called by the router to get the role used in routing. Standard value is \"app.User.getRole\" , which uses the (early loaded) User class that you can override (see \"Custom User class\" below) Caution : This is needed early in the routing process, and therefore should be able to answer right away (no promise). If this string does not represent a callable, it is used as a plain string value. (useful for no-login-dev-mode) controllersPath : String The root path of controllers. Standard value is \"/app/controllers\" *. modelsPath : String The root path of models. Standard value is \"/app/models\" *. viewsPath : String The root path of views. Standard value is \"/app/views\" *. Example config block: \"router\": { \"getRoleFrom\": \"app.User.getRole\", \"controllersPath\": \"/app/controllers/\", \"modelsPath\": \"/app/models/\", \"viewsPath\": \"/app/views/\" },","title":"Router config"},{"location":"app_config.html#custom-user-class","text":"String This is the name (without .js) of the file containing your override of the User class. Caution : The file cannot be called \"User\", as the loader would consider this class is already loaded. (the Baseclass is indeed) Look at the base class at /core/baseClasses/User.js to see the interface. Here is a typical example : 'use strict' app.LoadedClasses.User = class extends app.LoadedClasses.User { constructor(){ super(); } checkAuthenticated(callBack){ // Call an service to know if we are logged in fetch('https://mydomain/checkAuthenticated?'+crypto.randomUUID(),{ method: 'GET', credentials: 'include' }) .then(response => response.json()) .then(resp => { if(resp.success){ this.isAuthenticated = resp.data.isAuthenticated; if(resp.data.isAuthenticated) { // Meanwhile get user infos this.userInfo = resp.data.userInfo; callBack(); } else { console.warn('User was not authenticated !'); this.authUrl = resp.data.authUrl; callBack(); // sparCore defaults is call gotoLogin below } } else { console.error('Server error calling checkAuthenticated !?') } }); } gotoLogin(){ // Redirect, or call a service, or show a login button... document.location.href = 'https://mydomain.com/login.php'; } }","title":"Custom User class"},{"location":"app_config.html#message-bus-config","text":"This the configuration of the messagebus module. As messageBus uses Websocket-based communication, a lot of this config. has to do with WSS. enabled : Boolean When false, the messageBus is ...disabled ;-) pathToWorker\" : String This lib also uses a webworker which cannot be launched through the normal dependency system. This is the path to the worker script. Standard value is \"/core/libs/MessageBusWorker.js\" . protocol\" : The protocol part of the URL to the websocket server. Standard value is \"wss:\" . host\" : The host part of the URL to the websocket server. If absent or empty, the host will be extracted from the current browser's URL (same URL is a requirement often imposed by the browser, firewalls, proxies... anyway) port\" : The port part of the URL to the websocket server path\" : The (Where the HTTP-Upgrade will take place) connectTimeout : Float If the server remains silent at a connection attempt, connection will timeout after this many seconds. Caution : If autoReconnect is > 0, the Auto-reconnect will occur after connectTimeout + autoReconnect seconds, unless the door is immediately slammed in your face right away (then autoReconnect seconds). If your WSS server is hidden behind an Nginx (which you should really do in prod.), you should also pay attention to the Nginx parameters proxy_connect_timeout, proxy_send_timeout and proxy_read_timeout autoReconnect : Float If zero (or false): no auto-reconnect upon connection loss. Otherwise, the time, in seconds (decimals ok), before he FIRST reconnecting attempt. (ex: 5 seconds) autoReconnectTimeFactor : Float : on every successive reconnection failure, the auto-reconnect time is multiplied by this factor, to avoid reconnect-spamming when the WSS server is down. autoReconnectTimeMax : Float : The ceiling value for the auto-reconnect time. For example with autoReconnect:5, autoReconnectTimeFactor:2 , autoReconnectTimeMax:60 , attempts would occur at (connection loss) + 5sec, + 10sec, +20sec, +40sec then every minute ) autoReconnectJitterPercent : Float : If your websocket server goes down, all clients are loosing connection precisely at the same time. Therefore, their reconnection attempts will be synchronized, which is not what you want when you'll bring your WSS server back up ! If this parameter is non-zero, it represents the percentage of random \"jitter\" applied on the next reconnect time. For example: with a reconnect time of 30 sec, and autoReconnectJitterPercent:10 : the actual reconnection will occur between 28.5 and 31.5 seconds later. \"messageBus\":{ \"enabled\": true, \"pathToWorker\": \"/core/libs/MessageBusWorker.js\", \"protocol\": \"wss://\", \"port\": \"\", \"path\": \"/msgbus\", \"connectTimeout\": 5, \"autoReconnect\": 5, \"autoReconnectTimeFactor\": 1.3, \"autoReconnectTimeMax\": 30, \"autoReconnectJitterPercent\": 10 }","title":"Message Bus config"},{"location":"app_config.html#top-level-routes-definition","text":"Here are the definitions of the top-level routes used by the router. This file contains a Json Array of route objects such as for example : { \"url\": \"/module1/user:uid(\\\\d+)\", \"role\": \"theboss\", \"controller\" : \"/common/User/UserCtrl\", \"method\": \"userMod\" }, If you have tons of routes and want to keep this file reasonable, you can delegate \"sub-routes\" at each controller level. See \"Understanding the routing\" section for more details.","title":"Top level routes definition"},{"location":"assets_mgr.html","text":"Assets manager Images assets Fonts assets Styles assets Sounds assets Json assets Html assets Dead HTML vs Templating Templating with Template literals View templates assets","title":"Use Assets Manager"},{"location":"assets_mgr.html#assets-manager","text":"","title":"Assets manager"},{"location":"assets_mgr.html#images-assets","text":"","title":"Images assets"},{"location":"assets_mgr.html#fonts-assets","text":"","title":"Fonts assets"},{"location":"assets_mgr.html#styles-assets","text":"","title":"Styles assets"},{"location":"assets_mgr.html#sounds-assets","text":"","title":"Sounds assets"},{"location":"assets_mgr.html#json-assets","text":"","title":"Json assets"},{"location":"assets_mgr.html#html-assets","text":"","title":"Html assets"},{"location":"assets_mgr.html#dead-html-vs-templating","text":"","title":"Dead HTML vs Templating"},{"location":"assets_mgr.html#templating-with-template-literals","text":"","title":"Templating with Template literals"},{"location":"assets_mgr.html#view-templates-assets","text":"","title":"View templates assets"},{"location":"dependencies.html","text":"Dependencies definition Models and Views (sript) dependencies Other (script) dependencies Assets depedencies Special case of view-associated templates","title":"Dependencies definition"},{"location":"dependencies.html#dependencies-definition","text":"","title":"Dependencies definition"},{"location":"dependencies.html#models-and-views-sript-dependencies","text":"","title":"Models and Views (sript) dependencies"},{"location":"dependencies.html#other-script-dependencies","text":"","title":"Other (script) dependencies"},{"location":"dependencies.html#assets-depedencies","text":"","title":"Assets depedencies"},{"location":"dependencies.html#special-case-of-view-associated-templates","text":"","title":"Special case of view-associated templates"},{"location":"file_structure.html","text":"Sparc file structure Root directory : /app This is where your application lives, where you'll do your dev. work. /core This is where Sparc mechanics lives (you should not need to touch anything in here). /index.html This is the only HTML page ever loaded by your browser. These 10 lines of HTML are bootstrapping Sparc. (see the section about configuring your Nginx / Apache for Sparc) /core : You should not have to change anyting in here. If you do find something helpfull to change in the Core, please consider making a pull-request ;-) * /baseClasses - Contains model, view, controller and user base classes * /helpers - Helpers for Sparc itself * /libs - Libraries for sparc itself. Here lives the Router, the Assets manager, the Logger and the MessageBus. * /Sparc-core-1.0.js - Sparc bootstrap script. This is also where the Loader lives, as it is immediately needed to load internal (core) libs and MVC base-classes. * /utils /app : /assets This folder contains your images, fonts, style-sheets, sounds, static json, and html templates. This default path could be changed via assets.basePath setting in the application config. /config This folder contains json configuration files. /controllers This folder contains your controllers, eventually in a directory structure. This default path can be changed via router.controllersPath setting in the app. config. /docs This is where you should document your application...just a siggestion ;-). /helpers Put here any short, reusable piece of script that can be usefull anywhere in your app (any MVC components). Typically, you'll want to define global functions here like a date-conversion function, or enrich javascript-core prototypes, like adding a 'toCurrency' formatting method to the Number type for example. /libs Put here your large scripts, implementing a specific set of features that are not suited in a model, view or controller. Typically, a library defines a class that will be instantiated by models, views of controllers. thirdparty Put here any external libraries that you need. You probably want to git-ignore this folder ! /models This folder contains your models, eventually in a directory structure. This default path can be changed via router.modelsPath setting in the app. config. /views This folder contains your views, eventually in a directory structure. This default path can be changed via router.viewsPath setting in the app. config. /app/assets : fonts Put here all the fonts (like .ttf, .otf, .woff) that some of your views depends upon. html Put here all the static html fragments you might need in your views. Templating is allowed, using the standard \"template literals\" syntax of javascript. Template interpretation will activate if anf only if you pass a templateData object to the asset helpers functions. This is for general-purpose HTML fragments / templates. When your template is uniquely tied to a specific view, you probably want to store it in the views folder, alongside the corresponding javascript file (same name but .html). See the topic \"Using Assets manager\") images Put here all the images that some of your views depends upon. json Put here any piece of STATIC json that any component might depends upon. sfx Put here all the .mp3 sounds that some of your views depends upon. styles Put here all the .css files that some of your views depends upon.","title":"Understand the file structure"},{"location":"file_structure.html#sparc-file-structure","text":"","title":"Sparc file structure"},{"location":"file_structure.html#root-directory","text":"/app This is where your application lives, where you'll do your dev. work. /core This is where Sparc mechanics lives (you should not need to touch anything in here). /index.html This is the only HTML page ever loaded by your browser. These 10 lines of HTML are bootstrapping Sparc. (see the section about configuring your Nginx / Apache for Sparc)","title":"Root directory :"},{"location":"file_structure.html#core","text":"You should not have to change anyting in here. If you do find something helpfull to change in the Core, please consider making a pull-request ;-) * /baseClasses - Contains model, view, controller and user base classes * /helpers - Helpers for Sparc itself * /libs - Libraries for sparc itself. Here lives the Router, the Assets manager, the Logger and the MessageBus. * /Sparc-core-1.0.js - Sparc bootstrap script. This is also where the Loader lives, as it is immediately needed to load internal (core) libs and MVC base-classes. * /utils","title":"/core :"},{"location":"file_structure.html#app","text":"/assets This folder contains your images, fonts, style-sheets, sounds, static json, and html templates. This default path could be changed via assets.basePath setting in the application config. /config This folder contains json configuration files. /controllers This folder contains your controllers, eventually in a directory structure. This default path can be changed via router.controllersPath setting in the app. config. /docs This is where you should document your application...just a siggestion ;-). /helpers Put here any short, reusable piece of script that can be usefull anywhere in your app (any MVC components). Typically, you'll want to define global functions here like a date-conversion function, or enrich javascript-core prototypes, like adding a 'toCurrency' formatting method to the Number type for example. /libs Put here your large scripts, implementing a specific set of features that are not suited in a model, view or controller. Typically, a library defines a class that will be instantiated by models, views of controllers. thirdparty Put here any external libraries that you need. You probably want to git-ignore this folder ! /models This folder contains your models, eventually in a directory structure. This default path can be changed via router.modelsPath setting in the app. config. /views This folder contains your views, eventually in a directory structure. This default path can be changed via router.viewsPath setting in the app. config.","title":"/app :"},{"location":"file_structure.html#appassets","text":"fonts Put here all the fonts (like .ttf, .otf, .woff) that some of your views depends upon. html Put here all the static html fragments you might need in your views. Templating is allowed, using the standard \"template literals\" syntax of javascript. Template interpretation will activate if anf only if you pass a templateData object to the asset helpers functions. This is for general-purpose HTML fragments / templates. When your template is uniquely tied to a specific view, you probably want to store it in the views folder, alongside the corresponding javascript file (same name but .html). See the topic \"Using Assets manager\") images Put here all the images that some of your views depends upon. json Put here any piece of STATIC json that any component might depends upon. sfx Put here all the .mp3 sounds that some of your views depends upon. styles Put here all the .css files that some of your views depends upon.","title":"/app/assets :"},{"location":"mvc.html","text":"Write your Models, View and Controllers Models Quick reminder : Models implement the application's dynamic data structures, independent of the user interface. They directly manage the data, provide methods that help implement the logic and business rules of the application. On the client side, they also implement the exchanges with the Back-end (which -in turn- usually talks with a DB of any kind). In Sparc (like in most MVC frameworks), your models are javascript scripts that must implement a class which inherit from the model base-class (in core/baseClasses ) Views Quick reminder : Views implement any representation of information in text, tables, diagrams, etc. Multiple views of the same information are possible. Their algorithmic should concern only the (graphical) presentation of data. To implement a view client-side, you need two parts: some HTML, and some javascript that helps shaping it, and integrate data in it. In Sparc (again like in most MVC frameworks), your views are javascript scripts that must implement a class which inherit from the view base-class (in core/baseClasses ) About the HTML (or template), two approaches are possible (your choice) : Integrated views : the HTML is embed directly within your javascript code. Usually you would use template literals , by means of backtits, to avoid cumbresome concatenation of strings. Splitted script-HTML : If the HTML fragment is large, it is often more convenient to store it in a separate file, stored alongside the script. Sparc lets you do this easily, by using its internal dependency mechanism. (See the 'views' attribute of the controllers config). Both approaches can of course be combined in a single app, or even in a single view. A word about templating: When embedding HTML inside your javascript, you can use template literals. In other words, your HTML can include javascript expressions such as ${x+5} . They will be evaluated by javascript, using variables in the current scope, and replaced by their result. So what about templating in a \"splitted script-HTML\" context ? Templates are managed by the Assets manager, and it provides methods to integrate your view template into the existing DOM (namely: replaceByView, appendByView, prependByView ). One cool feature of these methods is that they accept an argument called templateData . templateData must be a key-value object, where the keys are matching your template variables. If present, it will trigger a genuine javascript-level \"template literals\" interpretation of your template. No new fancy templating engine dependency (your templates are agnostic), no new syntax to learn, 100% backward and forward compatibility with vanilla JS ! Fool-proof templating... As explained above, templates interpretation use the genuine vanilla-javascript internal interpretation, but with a small addition: In pure javascript, if an expression in the template is wrong (syntax or unknown variable), your script will crash. If you use the methods mentionned above, a pre-flight-check is performed on your template pefore handing it to interpretation: Any wrong expression will be suppressed, a clear warning will be issued at the console, and your template will not crash your view ! Controllers controllers config. Dependencies Models and Views (sript) dependencies Other (script) dependencies Assets depedencies","title":"Write your MVC components"},{"location":"mvc.html#write-your-models-view-and-controllers","text":"","title":"Write your Models, View and Controllers"},{"location":"mvc.html#models","text":"Quick reminder : Models implement the application's dynamic data structures, independent of the user interface. They directly manage the data, provide methods that help implement the logic and business rules of the application. On the client side, they also implement the exchanges with the Back-end (which -in turn- usually talks with a DB of any kind). In Sparc (like in most MVC frameworks), your models are javascript scripts that must implement a class which inherit from the model base-class (in core/baseClasses )","title":"Models"},{"location":"mvc.html#views","text":"Quick reminder : Views implement any representation of information in text, tables, diagrams, etc. Multiple views of the same information are possible. Their algorithmic should concern only the (graphical) presentation of data. To implement a view client-side, you need two parts: some HTML, and some javascript that helps shaping it, and integrate data in it. In Sparc (again like in most MVC frameworks), your views are javascript scripts that must implement a class which inherit from the view base-class (in core/baseClasses ) About the HTML (or template), two approaches are possible (your choice) : Integrated views : the HTML is embed directly within your javascript code. Usually you would use template literals , by means of backtits, to avoid cumbresome concatenation of strings. Splitted script-HTML : If the HTML fragment is large, it is often more convenient to store it in a separate file, stored alongside the script. Sparc lets you do this easily, by using its internal dependency mechanism. (See the 'views' attribute of the controllers config). Both approaches can of course be combined in a single app, or even in a single view. A word about templating: When embedding HTML inside your javascript, you can use template literals. In other words, your HTML can include javascript expressions such as ${x+5} . They will be evaluated by javascript, using variables in the current scope, and replaced by their result. So what about templating in a \"splitted script-HTML\" context ? Templates are managed by the Assets manager, and it provides methods to integrate your view template into the existing DOM (namely: replaceByView, appendByView, prependByView ). One cool feature of these methods is that they accept an argument called templateData . templateData must be a key-value object, where the keys are matching your template variables. If present, it will trigger a genuine javascript-level \"template literals\" interpretation of your template. No new fancy templating engine dependency (your templates are agnostic), no new syntax to learn, 100% backward and forward compatibility with vanilla JS ! Fool-proof templating... As explained above, templates interpretation use the genuine vanilla-javascript internal interpretation, but with a small addition: In pure javascript, if an expression in the template is wrong (syntax or unknown variable), your script will crash. If you use the methods mentionned above, a pre-flight-check is performed on your template pefore handing it to interpretation: Any wrong expression will be suppressed, a clear warning will be issued at the console, and your template will not crash your view !","title":"Views"},{"location":"mvc.html#controllers","text":"","title":"Controllers"},{"location":"mvc.html#controllers-config","text":"","title":"controllers config."},{"location":"mvc.html#dependencies","text":"","title":"Dependencies"},{"location":"mvc.html#models-and-views-sript-dependencies","text":"","title":"Models and Views (sript) dependencies"},{"location":"mvc.html#other-script-dependencies","text":"","title":"Other (script) dependencies"},{"location":"mvc.html#assets-depedencies","text":"","title":"Assets depedencies"},{"location":"routing.html","text":"Understand the routing Routes delegations: Routes must be defined in the \"baseRoutes.json\" file in the the application's config. However, when you have a large application, and therefore many routes, managing them all in a single file can become tedious. Therefore Sparc allows for route delegation, by having controller's configuration files deined their own (sub-) routes. A controller can only use URLs beginning by the URL which lead to him. (hence the \"delegation\" aspect much like DNS zones). When analysing the Browser's URL, the router will try all the known routes at that moment (which changes with delegation when new controllers are loaded). The route-findging algorithm goes as this: 1. Try to match the current URL againts each of all known routes. 2. When the URL matches, check that the user role matches the route role too, unless the route role is '*' (meaning everyone) 3. When something doesn not match, discard the route. 4. When both are ok, give this route a score which is the number of matching parts , then keep it as candidate. 5. When all known routes are exhausted, the candidate with the highest score is used. The routing algorithm then goes as this: 1. When the best route is found (see above), the router loads the config of the corresponding controller. 2. It then adds the routes eventually defined by that controller config. to the global routes list. 3. It now retries to route the URL, to see of some of these new routes give a better score. If yes, it recursively goes back to step 1. 4. When the route does not change anymore, we have found the best possible route, delegations included. It is now time to : 1. Instantiate the controller. 2. Choose the proper method: - If a method was specified in the route definition (see below), use it. - If not then use the last part of the url as the method name. 3. Build a parameters object conatining : - Static parameters found in the route definition (see below). - Dynamic parameters extracted (and enventually regexp-validated) from the URL Each part of the object above is described separately below : URL matching url : String [Mandatory] Is the URL pattern that the router will try to match the current browser's URL against. It can contain static parts, and dynamic parts (for parameters). For static parts (like \"/module1/user\" in the example above), the router will try to match it 'as is', at the right place. For dynamic parts (like :name or like \":uid(\\d+)\" in the example above), the router will take everything until the next '/' , or until the end of the URL. The string after the ':' will be used as parameter name. The parameter value (transmitted to the controller's method) will be the actual string found at this place of the URL. If the parameter name is followed by brackets, their content will be used as a regular expression to validate the parameter. Failure to validate a parameter leads to this route not matching. Roles matching role : String [Mandatory] Is the role to match with the current user role. Specifying '*' matches any user role. Controller selection controller : String [Mandatory] Is the controller's relative path inside the controllers basePath. This field is mandatory, unless the exturl is used instead. Method selection method : String [optional] If specified: the name of the method to call in that controller. In absent, the last segment of the URL will be used. Method parameters params : String [optional] An key:value object of static parameters passed to the method, alongside eventual dynamic parameters. Caution : if the same key is found as dynamic and static parameter, the static value will prevail . Special routing cases: The default route At least one route shall have as url the special value \"!defaultroute\" This route is used as the last-ressort route, when no matches could be found. This is the equivalent of a server 404 page (But there is no server, hence no status code here) The other parameters are as usual, no dynamic parameters are of-course allowed. You could have different default pages for different roles if you want (if it make sense for you, otherwise just use one default route with \"role\" : \"*\" ) External URLs If exturl is used instead of controller , then this route is considered to be external to the application and the user will be redirected to it. The role can be used in conjuction with it, but method and params are meaningless.","title":"Understand the routing"},{"location":"routing.html#understand-the-routing","text":"Routes delegations: Routes must be defined in the \"baseRoutes.json\" file in the the application's config. However, when you have a large application, and therefore many routes, managing them all in a single file can become tedious. Therefore Sparc allows for route delegation, by having controller's configuration files deined their own (sub-) routes. A controller can only use URLs beginning by the URL which lead to him. (hence the \"delegation\" aspect much like DNS zones). When analysing the Browser's URL, the router will try all the known routes at that moment (which changes with delegation when new controllers are loaded). The route-findging algorithm goes as this: 1. Try to match the current URL againts each of all known routes. 2. When the URL matches, check that the user role matches the route role too, unless the route role is '*' (meaning everyone) 3. When something doesn not match, discard the route. 4. When both are ok, give this route a score which is the number of matching parts , then keep it as candidate. 5. When all known routes are exhausted, the candidate with the highest score is used. The routing algorithm then goes as this: 1. When the best route is found (see above), the router loads the config of the corresponding controller. 2. It then adds the routes eventually defined by that controller config. to the global routes list. 3. It now retries to route the URL, to see of some of these new routes give a better score. If yes, it recursively goes back to step 1. 4. When the route does not change anymore, we have found the best possible route, delegations included. It is now time to : 1. Instantiate the controller. 2. Choose the proper method: - If a method was specified in the route definition (see below), use it. - If not then use the last part of the url as the method name. 3. Build a parameters object conatining : - Static parameters found in the route definition (see below). - Dynamic parameters extracted (and enventually regexp-validated) from the URL Each part of the object above is described separately below :","title":"Understand the routing"},{"location":"routing.html#url-matching","text":"url : String [Mandatory] Is the URL pattern that the router will try to match the current browser's URL against. It can contain static parts, and dynamic parts (for parameters). For static parts (like \"/module1/user\" in the example above), the router will try to match it 'as is', at the right place. For dynamic parts (like :name or like \":uid(\\d+)\" in the example above), the router will take everything until the next '/' , or until the end of the URL. The string after the ':' will be used as parameter name. The parameter value (transmitted to the controller's method) will be the actual string found at this place of the URL. If the parameter name is followed by brackets, their content will be used as a regular expression to validate the parameter. Failure to validate a parameter leads to this route not matching.","title":"URL matching"},{"location":"routing.html#roles-matching","text":"role : String [Mandatory] Is the role to match with the current user role. Specifying '*' matches any user role.","title":"Roles matching"},{"location":"routing.html#controller-selection","text":"controller : String [Mandatory] Is the controller's relative path inside the controllers basePath. This field is mandatory, unless the exturl is used instead.","title":"Controller selection"},{"location":"routing.html#method-selection","text":"method : String [optional] If specified: the name of the method to call in that controller. In absent, the last segment of the URL will be used.","title":"Method selection"},{"location":"routing.html#method-parameters","text":"params : String [optional] An key:value object of static parameters passed to the method, alongside eventual dynamic parameters. Caution : if the same key is found as dynamic and static parameter, the static value will prevail .","title":"Method parameters"},{"location":"routing.html#special-routing-cases","text":"","title":"Special routing cases:"},{"location":"routing.html#the-default-route","text":"At least one route shall have as url the special value \"!defaultroute\" This route is used as the last-ressort route, when no matches could be found. This is the equivalent of a server 404 page (But there is no server, hence no status code here) The other parameters are as usual, no dynamic parameters are of-course allowed. You could have different default pages for different roles if you want (if it make sense for you, otherwise just use one default route with \"role\" : \"*\" )","title":"The default route"},{"location":"routing.html#external-urls","text":"If exturl is used instead of controller , then this route is considered to be external to the application and the user will be redirected to it. The role can be used in conjuction with it, but method and params are meaningless.","title":"External URLs"}]}