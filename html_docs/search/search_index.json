{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to SPARC ___ ____ __ ____ ___ / __)( _ \\ /__\\ ( _ \\ / __) ___\\__ \\ )___//(__)\\ ) /( (__ (_______/(__) (__)(__)(_)\\_) \\___) Single Page Applications Rational Code Sparc is a javascript MVC framework for Single Page Applications Sparc main objectives MVC Model View Controller oriented (yes, Browser side), with a corresponding file structure for your javascript, templates and configuration files. Truly detached Your application boots, and serves all its different URLs without the help of a backend server. Only static files are used. Backend server is only there to answer to AJAX requests. Small footprint, fast serving Loads only what you need, just whene you need it: Scripts and Assets ( like images, fonts, css, ...) are loaded only once (clever non-browser caching), only when needed (lazy-loading). Clever Loading Scripts can depend on other scripts and on Assets. Define your dependency trees in clear JSON files, and Sparc will make sure everything your script needs is loaded beforehand. It will also optimize the loading by loading several things in parallel, but only where there is no risk to break a dependency. Powerful URL Routing Sparc lets you define route patterns in readable JSON files. Routes can be nested: a controller can redefine its own scope of routes. The URL patterns can use Regular Expressions, to extract named parameters. Methods can be specified, or not. A best match strategy is used when several routes are matching the URL + User role combination. Forward / Back buttons and internal links are intercepted to avoid any unwanted reload and the user is warned before exiting the application. External error logging Javascript Warnings and Errors in the console (from your code or directly from the browser) can trigger a fire-and-forget Ajax to any external service to have them store in a database, sent formated emails, etc... The error-level, the stack-trace and all relevant informations (like url, user, user-role) are included in the Json.","title":"Home"},{"location":"index.html#welcome-to-sparc","text":"___ ____ __ ____ ___ / __)( _ \\ /__\\ ( _ \\ / __) ___\\__ \\ )___//(__)\\ ) /( (__ (_______/(__) (__)(__)(_)\\_) \\___) Single Page Applications Rational Code","title":"Welcome to SPARC"},{"location":"index.html#sparc-is-a-javascript-mvc-framework-for-single-page-applications","text":"","title":"Sparc is a javascript MVC framework for Single Page Applications"},{"location":"index.html#sparc-main-objectives","text":"MVC Model View Controller oriented (yes, Browser side), with a corresponding file structure for your javascript, templates and configuration files. Truly detached Your application boots, and serves all its different URLs without the help of a backend server. Only static files are used. Backend server is only there to answer to AJAX requests. Small footprint, fast serving Loads only what you need, just whene you need it: Scripts and Assets ( like images, fonts, css, ...) are loaded only once (clever non-browser caching), only when needed (lazy-loading). Clever Loading Scripts can depend on other scripts and on Assets. Define your dependency trees in clear JSON files, and Sparc will make sure everything your script needs is loaded beforehand. It will also optimize the loading by loading several things in parallel, but only where there is no risk to break a dependency. Powerful URL Routing Sparc lets you define route patterns in readable JSON files. Routes can be nested: a controller can redefine its own scope of routes. The URL patterns can use Regular Expressions, to extract named parameters. Methods can be specified, or not. A best match strategy is used when several routes are matching the URL + User role combination. Forward / Back buttons and internal links are intercepted to avoid any unwanted reload and the user is warned before exiting the application. External error logging Javascript Warnings and Errors in the console (from your code or directly from the browser) can trigger a fire-and-forget Ajax to any external service to have them store in a database, sent formated emails, etc... The error-level, the stack-trace and all relevant informations (like url, user, user-role) are included in the Json.","title":"Sparc main objectives"},{"location":"app_config.html","text":"Application configuration There are two Json files located in /app/config : appConfig.json : General configuration parameters for this application. baseRoutes.json : Defines the top-level routes General configuration This configuration Json file contains one separated block for every configurable core library. Logger config (key: \"logger\") enabled : Boolean When false, the logger is ...disabled ;-) Importantly, that means that the browser console remains the original one. levels : Array Containing either 'warn', 'error' or both. postUrl : String The Url where the Json of the error will be posted Example config block: \"logger\": { \"enabled\": true, \"levels\": [\"warn\", \"err\"], \"postUrl\": \"https://mydomain.com/log2mail.php\" }, Example Error posted: \"level\":\"WARNING\", \"message\":\"In template employeeViews/EmployeeView.html, badvariable is not defined !\", \"user\":\"nike\", \"url\":\"https://mydomain.com/employees\", \"appName\":\"MyApp 2.0\", \"stacktrace\":[ [\"processTemplate\",\"Assets.js\",[\"221\",\"25\"]], [\"replaceByHtml\",\"Assets.js\",[\"241\",\"66\"]], [\"loadHtml\",\"Assets.js\",[\"182\",\"56\"]], [\"replaceByHtml\",\"Assets.js\",[\"246\",\"14\"]], [\"...all the way up to Sparc-core...\"] ] Assets manager config basePath : String The path where all assets are stored Example config block: \"assets\": { \"basePath\": \"/app/assets/\" }, Router config getRoleFrom : String This is a String that represents a function or method . It Will be called by the router to get the role used in routing. Standard value is \"app.User.getRole\" , which uses the (early loaded) User class that you can override (see \"Custom User class\" below) Caution : This is needed early in the routing process, and therefore should be able to answer right away (no promise). If this string does not represent a callable, it is used as a plain string value. (useful for no-login-dev-mode) controllersPath : String The root path of controllers. Standard value is \"/app/controllers\" *. modelsPath : String The root path of models. Standard value is \"/app/models\" *. viewsPath : String The root path of views. Standard value is \"/app/views\" *. Example config block: \"router\": { \"getRoleFrom\": \"app.User.getRole\", \"controllersPath\": \"/app/controllers/\", \"modelsPath\": \"/app/models/\", \"viewsPath\": \"/app/views/\" }, Custom User class String This is the name (without .js) of the file containing your override of the User class. Caution : The file cannot be called \"User\", as the loader would consider this class is already loaded. (the Baseclass is indeed) Look at the base class at /core/baseClasses/User.js to see the interface. Here is a typical example : 'use strict' app.LoadedClasses.User = class extends app.LoadedClasses.User { constructor(){ super(); } checkAuthenticated(callBack){ // Call an service to know if we are logged in fetch('https://mydomain/checkAuthenticated?'+crypto.randomUUID(),{ method: 'GET', credentials: 'include' }) .then(response => response.json()) .then(resp => { if(resp.success){ this.isAuthenticated = resp.data.isAuthenticated; if(resp.data.isAuthenticated) { // Meanwhile get user infos this.userInfo = resp.data.userInfo; callBack(); } else { console.warn('User was not authenticated !'); this.authUrl = resp.data.authUrl; callBack(); // sparCore defaults is call gotoLogin below } } else { console.error('Server error calling checkAuthenticated !?') } }); } gotoLogin(){ // Redirect, or call a service, or show a login button... document.location.href = 'https://mydomain.com/login.php'; } } Message Bus config This the configuration of the messagebus module. As messageBus uses Websocket-based communication, a lot of this config. has to do with WSS. enabled : Boolean When false, the messageBus is ...disabled ;-) pathToWorker\" : String This lib also uses a webworker which cannot be launched through the normal dependency system. This is the path to the worker script. Standard value is \"/core/libs/MessageBusWorker.js\" . protocol\" : The protocol part of the URL to the websocket server. Standard value is \"wss:\" . host\" : The host part of the URL to the websocket server. If absent or empty, the host will be extracted from the current browser's URL (same URL is a requirement often imposed by the browser, firewalls, proxies... anyway) port\" : The port part of the URL to the websocket server path\" : The (Where the HTTP-Upgrade will take place) connectTimeout : Float If the server remains silent at a connection attempt, connection will timeout after this many seconds. Caution : If autoReconnect is > 0, the Auto-reconnect will occur after connectTimeout + autoReconnect seconds, unless the door is immediately slammed in your face right away (then autoReconnect seconds). If your WSS server is hidden behind an Nginx (which you should really do in prod.), you should also pay attention to the Nginx parameters proxy_connect_timeout, proxy_send_timeout and proxy_read_timeout autoReconnect : Float If zero (or false): no auto-reconnect upon connection loss. Otherwise, the time, in seconds (decimals ok), before he FIRST reconnecting attempt. (ex: 5 seconds) autoReconnectTimeFactor : Float : on every successive reconnection failure, the auto-reconnect time is multiplied by this factor, to avoid reconnect-spamming when the WSS server is down. autoReconnectTimeMax : Float : The ceiling value for the auto-reconnect time. For example with autoReconnect:5, autoReconnectTimeFactor:2 , autoReconnectTimeMax:60 , attempts would occur at (connection loss) + 5sec, + 10sec, +20sec, +40sec then every minute ) autoReconnectJitterPercent : Float : If your websocket server goes down, all clients are loosing connection precisely at the same time. Therefore, their reconnection attempts will be synchronized, which is not what you want when you'll bring your WSS server back up ! If this parameter is non-zero, it represents the percentage of random \"jitter\" applied on the next reconnect time. For example: with a reconnect time of 30 sec, and autoReconnectJitterPercent:10 : the actual reconnection will occur between 28.5 and 31.5 seconds later. \"messageBus\":{ \"enabled\": true, \"pathToWorker\": \"/core/libs/MessageBusWorker.js\", \"protocol\": \"wss://\", \"port\": \"\", \"path\": \"/msgbus\", \"connectTimeout\": 5, \"autoReconnect\": 5, \"autoReconnectTimeFactor\": 1.3, \"autoReconnectTimeMax\": 30, \"autoReconnectJitterPercent\": 10 } Top level routes definition Here are the definitions of the top-level routes used by the router. This file contains a Json Array of route objects such as for example : { \"url\": \"/module1/user:uid(\\\\d+)\", \"role\": \"theboss\", \"controller\" : \"/common/User/UserCtrl\", \"method\": \"userMod\" }, See \"Understanding the routing\" section for more details.","title":"Configure your app"},{"location":"app_config.html#application-configuration","text":"There are two Json files located in /app/config : appConfig.json : General configuration parameters for this application. baseRoutes.json : Defines the top-level routes","title":"Application configuration"},{"location":"app_config.html#general-configuration","text":"This configuration Json file contains one separated block for every configurable core library.","title":"General configuration"},{"location":"app_config.html#logger-config-key-logger","text":"enabled : Boolean When false, the logger is ...disabled ;-) Importantly, that means that the browser console remains the original one. levels : Array Containing either 'warn', 'error' or both. postUrl : String The Url where the Json of the error will be posted Example config block: \"logger\": { \"enabled\": true, \"levels\": [\"warn\", \"err\"], \"postUrl\": \"https://mydomain.com/log2mail.php\" }, Example Error posted: \"level\":\"WARNING\", \"message\":\"In template employeeViews/EmployeeView.html, badvariable is not defined !\", \"user\":\"nike\", \"url\":\"https://mydomain.com/employees\", \"appName\":\"MyApp 2.0\", \"stacktrace\":[ [\"processTemplate\",\"Assets.js\",[\"221\",\"25\"]], [\"replaceByHtml\",\"Assets.js\",[\"241\",\"66\"]], [\"loadHtml\",\"Assets.js\",[\"182\",\"56\"]], [\"replaceByHtml\",\"Assets.js\",[\"246\",\"14\"]], [\"...all the way up to Sparc-core...\"] ]","title":"Logger config (key: \"logger\")"},{"location":"app_config.html#assets-manager-config","text":"basePath : String The path where all assets are stored Example config block: \"assets\": { \"basePath\": \"/app/assets/\" },","title":"Assets manager config"},{"location":"app_config.html#router-config","text":"getRoleFrom : String This is a String that represents a function or method . It Will be called by the router to get the role used in routing. Standard value is \"app.User.getRole\" , which uses the (early loaded) User class that you can override (see \"Custom User class\" below) Caution : This is needed early in the routing process, and therefore should be able to answer right away (no promise). If this string does not represent a callable, it is used as a plain string value. (useful for no-login-dev-mode) controllersPath : String The root path of controllers. Standard value is \"/app/controllers\" *. modelsPath : String The root path of models. Standard value is \"/app/models\" *. viewsPath : String The root path of views. Standard value is \"/app/views\" *. Example config block: \"router\": { \"getRoleFrom\": \"app.User.getRole\", \"controllersPath\": \"/app/controllers/\", \"modelsPath\": \"/app/models/\", \"viewsPath\": \"/app/views/\" },","title":"Router config"},{"location":"app_config.html#custom-user-class","text":"String This is the name (without .js) of the file containing your override of the User class. Caution : The file cannot be called \"User\", as the loader would consider this class is already loaded. (the Baseclass is indeed) Look at the base class at /core/baseClasses/User.js to see the interface. Here is a typical example : 'use strict' app.LoadedClasses.User = class extends app.LoadedClasses.User { constructor(){ super(); } checkAuthenticated(callBack){ // Call an service to know if we are logged in fetch('https://mydomain/checkAuthenticated?'+crypto.randomUUID(),{ method: 'GET', credentials: 'include' }) .then(response => response.json()) .then(resp => { if(resp.success){ this.isAuthenticated = resp.data.isAuthenticated; if(resp.data.isAuthenticated) { // Meanwhile get user infos this.userInfo = resp.data.userInfo; callBack(); } else { console.warn('User was not authenticated !'); this.authUrl = resp.data.authUrl; callBack(); // sparCore defaults is call gotoLogin below } } else { console.error('Server error calling checkAuthenticated !?') } }); } gotoLogin(){ // Redirect, or call a service, or show a login button... document.location.href = 'https://mydomain.com/login.php'; } }","title":"Custom User class"},{"location":"app_config.html#message-bus-config","text":"This the configuration of the messagebus module. As messageBus uses Websocket-based communication, a lot of this config. has to do with WSS. enabled : Boolean When false, the messageBus is ...disabled ;-) pathToWorker\" : String This lib also uses a webworker which cannot be launched through the normal dependency system. This is the path to the worker script. Standard value is \"/core/libs/MessageBusWorker.js\" . protocol\" : The protocol part of the URL to the websocket server. Standard value is \"wss:\" . host\" : The host part of the URL to the websocket server. If absent or empty, the host will be extracted from the current browser's URL (same URL is a requirement often imposed by the browser, firewalls, proxies... anyway) port\" : The port part of the URL to the websocket server path\" : The (Where the HTTP-Upgrade will take place) connectTimeout : Float If the server remains silent at a connection attempt, connection will timeout after this many seconds. Caution : If autoReconnect is > 0, the Auto-reconnect will occur after connectTimeout + autoReconnect seconds, unless the door is immediately slammed in your face right away (then autoReconnect seconds). If your WSS server is hidden behind an Nginx (which you should really do in prod.), you should also pay attention to the Nginx parameters proxy_connect_timeout, proxy_send_timeout and proxy_read_timeout autoReconnect : Float If zero (or false): no auto-reconnect upon connection loss. Otherwise, the time, in seconds (decimals ok), before he FIRST reconnecting attempt. (ex: 5 seconds) autoReconnectTimeFactor : Float : on every successive reconnection failure, the auto-reconnect time is multiplied by this factor, to avoid reconnect-spamming when the WSS server is down. autoReconnectTimeMax : Float : The ceiling value for the auto-reconnect time. For example with autoReconnect:5, autoReconnectTimeFactor:2 , autoReconnectTimeMax:60 , attempts would occur at (connection loss) + 5sec, + 10sec, +20sec, +40sec then every minute ) autoReconnectJitterPercent : Float : If your websocket server goes down, all clients are loosing connection precisely at the same time. Therefore, their reconnection attempts will be synchronized, which is not what you want when you'll bring your WSS server back up ! If this parameter is non-zero, it represents the percentage of random \"jitter\" applied on the next reconnect time. For example: with a reconnect time of 30 sec, and autoReconnectJitterPercent:10 : the actual reconnection will occur between 28.5 and 31.5 seconds later. \"messageBus\":{ \"enabled\": true, \"pathToWorker\": \"/core/libs/MessageBusWorker.js\", \"protocol\": \"wss://\", \"port\": \"\", \"path\": \"/msgbus\", \"connectTimeout\": 5, \"autoReconnect\": 5, \"autoReconnectTimeFactor\": 1.3, \"autoReconnectTimeMax\": 30, \"autoReconnectJitterPercent\": 10 }","title":"Message Bus config"},{"location":"app_config.html#top-level-routes-definition","text":"Here are the definitions of the top-level routes used by the router. This file contains a Json Array of route objects such as for example : { \"url\": \"/module1/user:uid(\\\\d+)\", \"role\": \"theboss\", \"controller\" : \"/common/User/UserCtrl\", \"method\": \"userMod\" }, See \"Understanding the routing\" section for more details.","title":"Top level routes definition"},{"location":"assets_mgr.html","text":"Assets manager Images assets Fonts assets Styles assets Sounds assets Json assets Html assets Dead HTML vs Templating Templating with Template literals View templates assets","title":"Use Assets Manager"},{"location":"assets_mgr.html#assets-manager","text":"","title":"Assets manager"},{"location":"assets_mgr.html#images-assets","text":"","title":"Images assets"},{"location":"assets_mgr.html#fonts-assets","text":"","title":"Fonts assets"},{"location":"assets_mgr.html#styles-assets","text":"","title":"Styles assets"},{"location":"assets_mgr.html#sounds-assets","text":"","title":"Sounds assets"},{"location":"assets_mgr.html#json-assets","text":"","title":"Json assets"},{"location":"assets_mgr.html#html-assets","text":"","title":"Html assets"},{"location":"assets_mgr.html#dead-html-vs-templating","text":"","title":"Dead HTML vs Templating"},{"location":"assets_mgr.html#templating-with-template-literals","text":"","title":"Templating with Template literals"},{"location":"assets_mgr.html#view-templates-assets","text":"","title":"View templates assets"},{"location":"dependencies.html","text":"Dependencies definition Models and Views (sript) dependencies Other (script) dependencies Assets depedencies Special case of view-associated templates","title":"Define your dependencies"},{"location":"dependencies.html#dependencies-definition","text":"","title":"Dependencies definition"},{"location":"dependencies.html#models-and-views-sript-dependencies","text":"","title":"Models and Views (sript) dependencies"},{"location":"dependencies.html#other-script-dependencies","text":"","title":"Other (script) dependencies"},{"location":"dependencies.html#assets-depedencies","text":"","title":"Assets depedencies"},{"location":"dependencies.html#special-case-of-view-associated-templates","text":"","title":"Special case of view-associated templates"},{"location":"file_structure.html","text":"Sparc file structure Root directory : /app This is where your application lives, where you'll do your dev. work. /core This is where Sparc mechanics lives (you should not need to touch anything in here). /index.html This is the only HTML page ever loaded by your browser. These 10 lines of HTML are bootstrapping Sparc. (see the section about configuring your Nginx / Apache for Sparc) /core : You should not have to change anyting in here. If you do find something helpfull to change in the Core, please consider making a pull-request ;-) * /baseClasses - Contains model, view, controller and user base classes * /helpers - Helpers for Sparc itself * /libs - Libraries for sparc itself. Here lives the Router, the Assets manager, the Logger and the MessageBus. * /Sparc-core-1.0.js - Sparc bootstrap script. This is also where the Loader lives, as it is immediately needed to load internal (core) libs and MVC base-classes. * /utils /app : /assets This folder contains your images, fonts, style-sheets, sounds, static json, and html templates. This default path could be changed via assets.basePath setting in the application config. /config This folder contains json configuration files. /controllers This folder contains your controllers, eventually in a directory structure. This default path can be changed via router.controllersPath setting in the app. config. /docs This is where you should document your application...just a siggestion ;-). /helpers Put here any short, reusable piece of script that can be usefull anywhere in your app (any MVC components). Typically, you'll want to define global functions here like a date-conversion function, or enrich javascript-core prototypes, like adding a 'toCurrency' formatting method to the Number type for example. /libs Put here your large scripts, implementing a specific set of features that are not suited in a model, view or controller. Typically, a library defines a class that will be instantiated by models, views of controllers. thirdparty Put here any external libraries that you need. You probably want to git-ignore this folder ! /models This folder contains your models, eventually in a directory structure. This default path can be changed via router.modelsPath setting in the app. config. /views This folder contains your views, eventually in a directory structure. This default path can be changed via router.viewsPath setting in the app. config. /app/assets : fonts Put here all the fonts (like .ttf, .otf, .woff) that some of your views depends upon. html Put here all the static html fragments you might need in your views. Templating is allowed, using the standard \"template literals\" syntax of javascript. Template interpretation will activate if anf only if you pass a templateData object to the asset helpers functions. This is for general-purpose HTML fragments / templates. When your template is uniquely tied to a specific view, you probably want to store it in the views folder, alongside the corresponding javascript file (same name but .html). See the topic \"Using Assets manager\") images Put here all the images that some of your views depends upon. json Put here any piece of STATIC json that any component might depends upon. sfx Put here all the .mp3 sounds that some of your views depends upon. styles Put here all the .css files that some of your views depends upon.","title":"Understand the file structure"},{"location":"file_structure.html#sparc-file-structure","text":"","title":"Sparc file structure"},{"location":"file_structure.html#root-directory","text":"/app This is where your application lives, where you'll do your dev. work. /core This is where Sparc mechanics lives (you should not need to touch anything in here). /index.html This is the only HTML page ever loaded by your browser. These 10 lines of HTML are bootstrapping Sparc. (see the section about configuring your Nginx / Apache for Sparc)","title":"Root directory :"},{"location":"file_structure.html#core","text":"You should not have to change anyting in here. If you do find something helpfull to change in the Core, please consider making a pull-request ;-) * /baseClasses - Contains model, view, controller and user base classes * /helpers - Helpers for Sparc itself * /libs - Libraries for sparc itself. Here lives the Router, the Assets manager, the Logger and the MessageBus. * /Sparc-core-1.0.js - Sparc bootstrap script. This is also where the Loader lives, as it is immediately needed to load internal (core) libs and MVC base-classes. * /utils","title":"/core :"},{"location":"file_structure.html#app","text":"/assets This folder contains your images, fonts, style-sheets, sounds, static json, and html templates. This default path could be changed via assets.basePath setting in the application config. /config This folder contains json configuration files. /controllers This folder contains your controllers, eventually in a directory structure. This default path can be changed via router.controllersPath setting in the app. config. /docs This is where you should document your application...just a siggestion ;-). /helpers Put here any short, reusable piece of script that can be usefull anywhere in your app (any MVC components). Typically, you'll want to define global functions here like a date-conversion function, or enrich javascript-core prototypes, like adding a 'toCurrency' formatting method to the Number type for example. /libs Put here your large scripts, implementing a specific set of features that are not suited in a model, view or controller. Typically, a library defines a class that will be instantiated by models, views of controllers. thirdparty Put here any external libraries that you need. You probably want to git-ignore this folder ! /models This folder contains your models, eventually in a directory structure. This default path can be changed via router.modelsPath setting in the app. config. /views This folder contains your views, eventually in a directory structure. This default path can be changed via router.viewsPath setting in the app. config.","title":"/app :"},{"location":"file_structure.html#appassets","text":"fonts Put here all the fonts (like .ttf, .otf, .woff) that some of your views depends upon. html Put here all the static html fragments you might need in your views. Templating is allowed, using the standard \"template literals\" syntax of javascript. Template interpretation will activate if anf only if you pass a templateData object to the asset helpers functions. This is for general-purpose HTML fragments / templates. When your template is uniquely tied to a specific view, you probably want to store it in the views folder, alongside the corresponding javascript file (same name but .html). See the topic \"Using Assets manager\") images Put here all the images that some of your views depends upon. json Put here any piece of STATIC json that any component might depends upon. sfx Put here all the .mp3 sounds that some of your views depends upon. styles Put here all the .css files that some of your views depends upon.","title":"/app/assets :"},{"location":"mvc.html","text":"Write your Models, View and Controllers Models Views Controllers Nested routes Dependencies","title":"Write your MVC components"},{"location":"mvc.html#write-your-models-view-and-controllers","text":"","title":"Write your Models, View and Controllers"},{"location":"mvc.html#models","text":"","title":"Models"},{"location":"mvc.html#views","text":"","title":"Views"},{"location":"mvc.html#controllers","text":"","title":"Controllers"},{"location":"mvc.html#nested-routes","text":"","title":"Nested routes"},{"location":"mvc.html#dependencies","text":"","title":"Dependencies"},{"location":"routing.html","text":"If you have tons of routes and want to keep this file reasonable, you can delegate \"sub-routes\" at each controller level. A controller can only use URLs beginning by the URL which lead to him. (hence the \"delegation\" aspect much like DNS zones). When analysing the Browser's URL, the router will try all the known routes at that moment (which changes with delegation when new controllers are loaded). The route-findging algorithm goes as this: 1. Try to match the current URL againts each of all known routes. 2. When the URL matches, check that the user role matches the route role too, unless the route role is '*' (meaning everyone) 3. When something doesn not match, discard the route. 4. When both are ok, give this route a score which is the number of matching parts , then keep it as candidate. 5. When all known routes are exhausted, the candidate with the highest score is used. The routing algorithm then goes as this: 1. When the best route is found (see above), the router loads the config of the corresponding controller. 2. It then adds the routes eventually defined by that controller config. to the global routes list. 3. It now retries to route the URL, to see of some of these new routes gives a better score. If yes, it recursively goes back to step 1. 4. When the route does not change anymore, we have found the best possible route, delegations included. It is now time to : 1. Instantiate the controller. 2. Choose the proper method: - If a method was specified in the route definition (see below), use it. - If not then use the last part of the url as the method name. 3. Build a parameters object conatining : - Static parameters found in the route definition (see below). - Dynamic parameters extracted (and enventually regexp-validated) from the URL Each part of the object above is described separately below : URL matching url : String Is the URL pattern that the router will try to match the current browser's URL against. It can contain static parts, and dynamic parts (for parameters). For static parts (like \"/module1/user\" in the example above), the router will try to match it 'as is', at the right place. For dynamic parts (like :name or like \":uid(\\d+)\" in the example above), the router will take everything until the next '/' , or until the end of the URL. The string after the ':' will be used as parameter name. The parameter value (transmitted to the controller's method) will be the actual string found at this place of the URL. If the parameter name is followed by brackets, their content will be used as a regular expression to validate the parameter. Failure to validate a parameter leads to this route not matching. Roles matching role : String Is the role to match with the current user role. if '*' then it matches any user role. Controller selection controller : String Method selection method : String Method parameters params : String","title":"Understanding the routing"},{"location":"routing.html#url-matching","text":"url : String Is the URL pattern that the router will try to match the current browser's URL against. It can contain static parts, and dynamic parts (for parameters). For static parts (like \"/module1/user\" in the example above), the router will try to match it 'as is', at the right place. For dynamic parts (like :name or like \":uid(\\d+)\" in the example above), the router will take everything until the next '/' , or until the end of the URL. The string after the ':' will be used as parameter name. The parameter value (transmitted to the controller's method) will be the actual string found at this place of the URL. If the parameter name is followed by brackets, their content will be used as a regular expression to validate the parameter. Failure to validate a parameter leads to this route not matching.","title":"URL matching"},{"location":"routing.html#roles-matching","text":"role : String Is the role to match with the current user role. if '*' then it matches any user role.","title":"Roles matching"},{"location":"routing.html#controller-selection","text":"controller : String","title":"Controller selection"},{"location":"routing.html#method-selection","text":"method : String","title":"Method selection"},{"location":"routing.html#method-parameters","text":"params : String","title":"Method parameters"}]}